<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
    <channel>
        <title>fantasticsid</title>
        <link>http://blog.fantasticsid.com</link>
        <description><![CDATA[mathematics, computer science, haskell, clojure, scala, erlang, C++, python, music]]></description>
        <atom:link href="http://blog.fantasticsid.com/rss.xml" rel="self"
                   type="application/rss+xml" />
        <lastBuildDate>Fri, 05 Apr 2013 00:00:00 UT</lastBuildDate>
        <item>
    <title>C++ Templates: The Complete Guide 笔记</title>
    <link>http://blog.fantasticsid.com/posts/2013-04-05-cpp-template.html</link>
    <description><![CDATA[<article>
  <header>
    <div class="content">
      <div class="nav">
        <a href="/posts.html">← All posts</a>
      </div>
    <p class="meta"><time class="timeago" datetime="2013-04-05" pubdate>2013-04-05</time></p>
    <h1>C++ Templates: The Complete Guide 笔记</h1>
    </header>
  <section>
    <ol style="list-style-type: decimal">
<li>这里解释了作者认为const放在类型之后的好处: 比如</li>
</ol>
<pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">typedef</span> <span class="dt">char</span>* CHARS;
<span class="kw">typedef</span> CHARS <span class="dt">const</span> CPTR;</code></pre>
<p>这样声明的CPTR就是一个“constant pointer to chars”, 因为展开之后就是</p>
<pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">typedef</span> <span class="dt">char</span>* <span class="dt">const</span> CPTR;</code></pre>
<p>相反</p>
<pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">typedef</span> <span class="dt">char</span> * CHARS;
<span class="kw">typedef</span> <span class="dt">const</span> CHARS CPTR;</code></pre>
<p>展开之后为:</p>
<pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">typedef</span> <span class="dt">const</span> <span class="dt">char</span> * CPTR;
<span class="dt">int</span> main();</code></pre>
<p>这里const修饰的就不是CPTR了.</p>
<p>另外, 推荐的引用和指针参数的空格放置位置</p>
<pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">void</span> foo(<span class="dt">int</span> <span class="dt">const</span>&amp; x);</code></pre>
<p>倒也是和工作时C++代码的风格一样的.</p>
<ol start="2" style="list-style-type: decimal">
<li>函数模板</li>
</ol>
<ul>
<li>template声明中使用typename较常用</li>
<li>对于一个类型, 如果实例化函数模板后使用到了不支持的操作符, 会产生编译错误</li>
</ul>
<pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">template</span> &lt;<span class="kw">typename</span> T&gt;
T lt(T <span class="dt">const</span>&amp; a, T <span class="dt">const</span>&amp; b)
{
  <span class="kw">return</span> a * b;
}

lt(<span class="st">&quot;hi&quot;</span>, <span class="st">&quot;ya&quot;</span>); <span class="co">// error</span></code></pre>
<ul>
<li>函数模板的编译经过至少2层, 模板本身的语法, 以及实例化之后的语义检查</li>
<li>模板函数参数的自动推导中不允许类型转化, 类型必须完全匹配. 解决的方法是转化实参的类型或者显示实例化模板参数</li>
</ul>
<pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">template</span> &lt;<span class="kw">typename</span> T&gt;
T lt(T <span class="dt">const</span>&amp; a, T <span class="dt">const</span>&amp; b)
{
  <span class="kw">return</span> a &lt; b;
}

lt(<span class="dv">4</span>, <span class="fl">5.0</span>); <span class="co">// error</span>
lt&lt;<span class="dt">float</span>&gt;(<span class="dv">4</span>, <span class="fl">5.0</span>); <span class="co">// correct</span></code></pre>
<ul>
<li>函数模板不能有默认参数</li>
<li>函数模板可以重载(参数个数不同), 可以进行特例化, 可以与非函数模板共存. 后者在选择时有更高的优先权</li>
</ul>
<ol start="3" style="list-style-type: decimal">
<li>类模板</li>
</ol>
<ul>
<li>类模板的成员函数的实例化是惰性的</li>
<li>类模板特例化, 可以部分特例化</li>
<li>类模板参数可以有默认值, 并且可以引用之前的模板参数</li>
</ul>
<pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">template</span> &lt; <span class="kw">typename</span> T, <span class="kw">typename</span> CONT = vector&lt;T&gt; &gt;
<span class="kw">class</span> A;</code></pre>
<ol start="4" style="list-style-type: decimal">
<li>非类型的模板参数 (dependent types)</li>
</ol>
<ul>
<li>模板参数不必要是一个类型, 还可以是整形值</li>
<li>不同整型值构造出来的类型是不一样的, 比如长度为10的List, 和长度为20的List是不同的</li>
<li>模板类和模板函数都可以用整型值来实例化</li>
<li>甚至外部链接的字符串常量也可以作为模板参数</li>
</ul>
<ol start="5" style="list-style-type: decimal">
<li>一些细节</li>
</ol>
<ul>
<li>通常类内的typedef在别处使用时要用typename作修饰, 以免被编译器认为是静态类成员变量</li>
<li>模板成员函数使用时如果进行了显示的特例化, 需要在“.”, “-&gt;”之后加上template以免编译器把“&lt;”认为是小于操作符</li>
<li>模板类继承之后, 调用成员函数需要用“this-&gt;memfn()”</li>
<li>模板本身也可以成为模板的实参 (template template arguments), 使用时不能利用默认参数</li>
</ul>
<ol start="6" style="list-style-type: decimal">
<li>模板文件包含模式</li>
</ol>
<ul>
<li>由于模板的实例化发生在编译期, 所以如果使用的模板定义在另外一个编译单元中, 则需要确保有恰当的实例化发生</li>
</ul>
<pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// template.hpp</span>
<span class="kw">template</span> &lt;<span class="kw">typename</span> T&gt;
<span class="dt">void</span> print(T <span class="dt">const</span>&amp;);

<span class="co">// template.cpp</span>
<span class="kw">template</span> &lt;<span class="kw">typename</span> T&gt;
<span class="dt">void</span> print(T <span class="dt">const</span>&amp; x)
{
<span class="co">// implementation</span>
}

<span class="co">// prog.cpp</span>
<span class="ot">#include &quot;template.hpp&quot;</span>
<span class="dt">int</span> main()
{
<span class="dt">double</span> v = <span class="fl">1.0</span>;
print(v);
<span class="kw">return</span> <span class="dv">0</span>;
}</code></pre>
<p>这里由于模板定义在另外一个编译单元(template.cpp), 而在其中并没有对double类型进行实例化的需要, 因此编译结果中并没有 print<double>(double const&amp; x) 这个函数. 而对prog.cpp的编译能够通过是因为其中包含了template.hpp中的print模板函数的声明. 这样就导致了编译能够通过, 但是链接阶段会发生错误.</p>
<p>解决方法:</p>
<ol style="list-style-type: decimal">
<li><p>把模板实现放在模板声明中 (Inclusion model)</p></li>
<li><p>显示实例化</p></li>
</ol>
<pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// template.cpp</span>
<span class="kw">template</span> <span class="dt">void</span> print&lt;<span class="dt">double</span>&gt;(<span class="dt">double</span> <span class="dt">const</span> &amp;);</code></pre>
<p>这样template.cpp编译单元中就会实例化相应的函数, 缺点是难以管理</p>
<ol start="3" style="list-style-type: decimal">
<li>结合上面两种方法, 提供额外的编译单元专门提供特例化声明</li>
</ol>
<ul>
<li>使用export (Separation model)</li>
</ul>
<pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">export</span>
<span class="kw">template</span> &lt;<span class="kw">typename</span> T&gt;
<span class="dt">void</span> print(T <span class="dt">const</span>&amp;);</code></pre>
<p>缺点是编译器实现支持较少</p>
<ul>
<li><p>预编译头文件 - 编译器的优化可以保存前n行代码编译之后的状态, 这使得开头一样的编译单元(都包含了相同的头文件)的编译速度得以提高.</p></li>
<li><p>模板编译错误的找错: 找到模板实例化处</p></li>
<li><p>Archetypes: 模板库编写者提供的满足模板最小要求的类示例</p></li>
</ul>
<ol start="7" style="list-style-type: decimal">
<li>模板术语</li>
</ol>
<ul>
<li><p>Class template</p></li>
<li><p>Instantiation and specialization</p></li>
<li><p>Declaration vs definition</p></li>
<li><p>Template arguments vs template parameters</p></li>
</ul>
<ol start="8" style="list-style-type: decimal">
<li>模板参数限制</li>
</ol>
<ul>
<li><p>模板定义分为类模板和函数模板, 其中还包括了类模板的成员函数, 类模板的嵌套类(nested class)定义和成员定义, 模板类的静态变量的模板定义</p></li>
<li><p>模板成员函数不能被定义为虚函数, 因为虚表通常是用固定大小的表实现的. 而“模板虚函数”的个数只有到最后整个程序构建玩才能确定, 所以实现这个特性需要编译器, 连接器的支持</p></li>
<li><p>主模板定义</p></li>
</ul>
<pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// primary template</span>
<span class="kw">template</span> &lt;<span class="kw">typename</span> T&gt;
<span class="kw">class</span> Box;

<span class="co">// non-primary template</span>
<span class="kw">template</span> &lt;<span class="kw">typename</span> T&gt;
<span class="kw">class</span> Box&lt;T&gt;;</code></pre>
<ul>
<li><p>模板参数分为: 类型参数, 非类型参数(non-type parameters), 模板参数</p></li>
<li><p>非类型参数包括整形/枚举, 指针, 引用</p></li>
<li><p>模板参中的默认值可以在模板定义内使用, 但是模板显式实例化时模板类参数的参数个数(kind)必须与形参声明一样</p></li>
<li>模板实参
<ul>
<li>只有模板类声明时可以有默认参数</li>
<li>template-id: 显式模板参数T&lt;P1, P2, P3&gt;</li>
<li>模板类定义作用域之内, 对类名的引用相当于tempate-id</li>
<li>默认模板参数可省略, 但是“&lt;&gt;”仍然是必要的</li>
<li>模板函数参数类型推导</li>
</ul></li>
<li><p>substitution-failure-is-not-an-error (SFINAE)</p></li>
</ul>
<pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">template</span> &lt;<span class="kw">typename</span> T&gt;
RT1 test(<span class="kw">typename</span> T::X <span class="dt">const</span>*);

<span class="kw">template</span> &lt;<span class="kw">typename</span> T&gt;
RT2 test(...);

<span class="kw">typedef</span> <span class="dt">char</span> RT1;
<span class="kw">typedef</span> <span class="kw">struct</span> { <span class="dt">char</span> a[<span class="dv">2</span>]; } RT2;

<span class="ot">#define type_has_member_type_X(T) (sizeof(test&lt;T&gt;(0)) == 1)</span></code></pre>
<p>对没有定义成员X的类来说, 第一个模板函数定义应该产生编译错误, 但是因为SFINAE原则编译器选择继续从下一个模板定义来实例化test这个函数的调用</p>
<p>SFINAE只能处理产生非法类型的错误, 别的错误(除零错误等)则不适用.</p>
<ul>
<li><p>局部类定义不能用作模板参数, 无名类型/枚举也不行(除非用typedef指定一个名字)</p></li>
<li><p>成员函数模板的实例化不重载虚函数</p></li>
</ul>
<pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="ot">#include &lt;iostream&gt;</span>

<span class="kw">class</span> A
{
<span class="kw">public</span>:
  <span class="kw">virtual</span> <span class="dt">void</span> fun(<span class="dt">int</span> a)
  {
    std::cout &lt;&lt; <span class="st">&quot;A &quot;</span> &lt;&lt; a &lt;&lt; std::endl;
  }

  <span class="kw">virtual</span> ~A() {}
};

<span class="kw">template</span> &lt;<span class="kw">typename</span> T&gt;
<span class="kw">class</span> B: <span class="kw">public</span> A
{
<span class="kw">public</span>:
  <span class="kw">template</span> &lt;<span class="kw">typename</span> T2&gt;
  <span class="dt">void</span> fun(T2 a)
  {
    std::cout &lt;&lt; <span class="st">&quot;B &quot;</span> &lt;&lt; a &lt;&lt; std::endl;
  }

  <span class="kw">virtual</span> ~B() {}
};

<span class="kw">class</span> C: <span class="kw">public</span> A
{
<span class="kw">public</span>:
  <span class="dt">void</span> fun(<span class="dt">int</span> a)
  {
    std::cout &lt;&lt; <span class="st">&quot;C &quot;</span> &lt;&lt; a &lt;&lt; std::endl;
  }
};

<span class="dt">int</span> main(<span class="dt">int</span> argc, <span class="dt">char</span> *argv[])
{
  A *pa = <span class="kw">new</span> B&lt;<span class="dt">int</span>&gt;();
  pa-&gt;fun(<span class="dv">2</span>);
  <span class="kw">delete</span> pa;

  B&lt;<span class="dt">int</span>&gt; b;
  b.fun(<span class="dv">2</span>);

  pa = <span class="kw">new</span> C();
  pa-&gt;fun(<span class="dv">2</span>);
  <span class="kw">delete</span> pa;

  <span class="kw">return</span> <span class="dv">0</span>;
}
</code></pre>
<p>输出为:</p>
<pre><code>A 2
B 2
C 2</code></pre>
<ul>
<li><p>模板友类的声明处必须可见友类本身的定义, 一般类没有这个限制</p></li>
<li><p>友函数声明可以是定义, 因此如果实例化若干模板类, 会重复定义此函数, 解决办法是让函数依赖于模板参数</p></li>
<li><p>友模板: 声明一个模板的所有实例化都是友函数/类</p></li>
</ul>
<pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">class</span> Manager {
  <span class="kw">template</span> &lt;<span class="kw">typename</span> T&gt;
    <span class="kw">friend</span> <span class="kw">class</span> Task;

  <span class="kw">template</span> &lt;<span class="kw">typename</span> T&gt;
    <span class="kw">friend</span> <span class="dt">void</span> Schedule&lt;T&gt;::dispatch(Task&lt;T&gt;*);

  <span class="kw">template</span> &lt;<span class="kw">typename</span> T&gt;
    <span class="kw">friend</span> <span class="dt">int</span> ticket() {
      <span class="kw">return</span> ++Manager::counter;
    }

  <span class="dt">static</span> <span class="dt">int</span> counter;
};</code></pre>
<ol start="8" style="list-style-type: decimal">
<li>模板中的命名</li>
</ol>
<ul>
<li>C++语法并不是上下文无关的</li>
</ul>
<pre class="sourceCode cpp"><code class="sourceCode cpp">
x * y;</code></pre>
<p>以上代码可以是一个乘法表达式, 也可能是一个指针声明. 这要视x的定义而定.</p>
<ul>
<li><p>Template-id: 模板与模板参数的组合, 如List<T, int, 0></p></li>
<li><p>qualifed name的查找, unqualified name的查找(类作用域, 基类作用域, … , 嵌套的外层作用域), 这种查找是最普通的. C++中还有一个规则: Argument dependent lookup, 又称koenig lookup</p></li>
<li><p>对于一个class, ADL规则会检查类本身, 包含类定义的外层类, 基类这些类声明处的namespace.</p></li>
<li><p>对于函数调用, 函数参数以及返回值的类型关联的名称空间是ADL的查找范围.</p></li>
</ul>
<pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="ot">#include &lt;iostream&gt;</span>

<span class="kw">namespace</span> X {
  <span class="kw">template</span>&lt;<span class="kw">typename</span> T&gt; <span class="dt">void</span> f(T);
}

<span class="kw">namespace</span> N {
  <span class="kw">using</span> <span class="kw">namespace</span> X; <span class="co">// ADL查找时, 此处没有引入X::f</span>
  <span class="kw">enum</span> E{ e };
  <span class="dt">void</span> f(E) {
    std::cout &lt;&lt; <span class="st">&quot;N::f&quot;</span> &lt;&lt; std::endl;
  }
}

<span class="dt">void</span> f(<span class="dt">int</span>)
{
  std::cout &lt;&lt; <span class="st">&quot;::f&quot;</span> &lt;&lt; std::endl;
}

<span class="dt">int</span> main(<span class="dt">int</span> argc, <span class="dt">char</span> *argv[])
{
  ::f(N::e); <span class="co">// ::f</span>
  f(N::e); <span class="co">// N::f</span>
}</code></pre>
<ul>
<li>类定义内可以引用类名本身, 模板类中可以引用模板类名并加上模板参数. 但是如果只用模板类名, 则代表着和当前instantiation相对应的template-id, 而不是一个类模板</li>
</ul>
<pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">template</span> &lt;<span class="kw">template</span>&lt;<span class="kw">typename</span>&gt; <span class="kw">class</span> TT&gt;
<span class="kw">class</span> X
{
}

<span class="kw">template</span> &lt;<span class="kw">typename</span> T&gt;
<span class="kw">class</span> C
{
  C a; <span class="co">// 代表C&lt;T&gt; a;</span>
  C&lt;<span class="dt">void</span>&gt; b;
  X&lt;C&gt; c; <span class="co">// 这里不行, C不代表一个模板类的名称</span>
  X&lt;::C&gt; d; <span class="co">// &lt;: 是特殊字符序列, 代表 [</span>
  X&lt; ::C&gt; e; <span class="co">// 总算行了这里</span>
}</code></pre>
<ul>
<li><p>为了处理C++这样的上下文相关文法, 编译器有一个符号表记录各种声明. 这样就能区分比如x*究竟是一个声明还是乘法表达式的一部分了. 类似的例子还有X&lt;1&gt;(0)等(视X是否为模板类)</p></li>
<li><p>Tokenizer也会有类似问题, 最常见的问题是模板实例作为模板参数: List<List<int>&gt;, 这里&gt;&gt;会被解释为一个右移运算符. 有的编译器为这个问题作了特殊处理, 并給予警告.</p></li>
<li><p>Dependent names: 模板定义中对另外一个模板类定义的名称引用是不合适的, 因为很可能显示模板化会改变这个名称的定义</p></li>
</ul>
<pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">template</span> &lt;<span class="kw">typename</span> T&gt;
<span class="kw">class</span> Trap {
<span class="kw">public</span>:
  <span class="kw">enum</span> {x};
};

<span class="kw">template</span> &lt;<span class="kw">typename</span> T&gt;
<span class="kw">class</span> Victim {
<span class="kw">public</span>:
  <span class="dt">int</span> y;
  <span class="dt">void</span> poof() {
    Trap&lt;T&gt;::x * y; <span class="co">// 这里是声明还是乘法表达式?</span>
  }
};

<span class="kw">template</span> &lt;&gt;
<span class="kw">class</span> Trap&lt;<span class="dt">void</span>&gt; {
<span class="kw">public</span>:
  <span class="kw">typedef</span> <span class="dt">int</span> x;
}

<span class="dt">void</span> <span class="dt">bool</span>(Victim&lt;<span class="dt">void</span>&gt;&amp; bomb) <span class="co">// 书上这里是Trap&lt;void&gt;&amp;</span>
{
  bomb.poof()
}</code></pre>
<p>如果在Victim模板定义内部查找x的定义, 则认为x是一个enum值, 但是后面Trap对void的显示化却对覆盖了x的定义.</p>
<p>C++的解决方法是: 默认情况下不认为一个dependent name是一个type, 除非用typename作声明.</p>
<p>当一个名称 1. 出现在模板定义内 2. 是被限定的(qualified) 3. 不作为基类声明/成员初始化列表中作为类型 4. 依赖于模板参数</p>
<p>则必须对之进行typename修饰. 看到这里感觉要吐了, 的确C++的template是非常的复杂, 需要知道的细节太多.</p>
<pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">template</span> &lt;<span class="kw">typename</span> T&gt;
<span class="kw">struct</span> S: <span class="kw">typename</span> X&lt;T&gt;::Base {
  S(): <span class="kw">typename</span> X&lt;T&gt;::Base(<span class="kw">typename</span> X&lt;T&gt;::Base(<span class="dv">0</span>)) {}
  <span class="kw">typename</span> X&lt;T&gt; f() {
    <span class="kw">typename</span> X&lt;T&gt;::C * p; <span class="co">// 声明</span>
    X&lt;T&gt;::D * q; <span class="co">// 乘法表达式</span>
  }
  <span class="kw">typename</span> X&lt;<span class="dt">int</span>&gt;::C * s;
};

<span class="kw">struct</span> U {
  <span class="kw">typename</span> X&lt;<span class="dt">int</span>&gt;::C * pc;
};</code></pre>
<pre><code>* 这个例子当中typename X&lt;T&gt;::Base中的typename是多余的, 因为他们不满足第3条规则.

* 但是紧接着的typename X&lt;T&gt;::Base(0)中typename是必须的, 因为这里构造了一个对象.
* 下面的typename X&lt;T&gt;中typename又是多余的, 这里没有限定名称(qualified name).
* typename X&lt;T&gt;::C * p中typename是必须的, 否则就如下一行编译器认为其是一个乘法表达式.
* 最后的typename X&lt;int&gt;::C * s说明了即使不满足第4条规则, 依然可以加上typename修饰, 反过来说, 前三条对typename的使用也是必要的.</code></pre>
<ul>
<li>类似的, 如果一个template定义也是有依赖的, 则必须告诉编译器.</li>
</ul>
<pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">template</span> &lt;<span class="kw">typename</span> T&gt;
<span class="kw">class</span> Shell {
<span class="kw">public</span>:
  <span class="kw">template</span> &lt;<span class="dt">int</span> N&gt;
  <span class="kw">class</span> In {
  <span class="kw">public</span>:
    <span class="kw">template</span> &lt;<span class="dt">int</span> M&gt;
    <span class="kw">class</span> Deep {
    <span class="kw">public</span>:
      <span class="kw">virtual</span> <span class="dt">void</span> f();
    };
  };
};

<span class="kw">template</span> &lt;<span class="kw">typename</span> T, <span class="dt">int</span> N&gt;
<span class="kw">class</span> Weird {
<span class="kw">public</span>:
  <span class="dt">void</span> case1(Shell&lt;T&gt;::<span class="kw">template</span> In&lt;N&gt;::<span class="kw">template</span> Deep&lt;N&gt; * p) {
    p-&gt;<span class="kw">template</span> Deep&lt;N&gt;::f();
  }
  <span class="dt">void</span> case2(Shell&lt;T&gt;::<span class="kw">template</span> In&lt;T&gt;::<span class="kw">template</span> Deep&lt;T&gt;&amp; p) {
    p.<span class="kw">template</span> Deep&lt;N&gt;::f();
  }
};</code></pre>
  </section>

  <section id="comment">

    <div id="disqus_thread"></div>
    <script type="text/javascript">
      /* * * CONFIGURATION VARIABLES: EDIT BEFORE PASTING INTO YOUR WEBPAGE * * */
      var disqus_shortname = 'fantasticsidtheblog'; // required: replace example with your forum shortname

      /* * * DON'T EDIT BELOW THIS LINE * * */
      (function() {
      var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
      dsq.src = 'http://' + disqus_shortname + '.disqus.com/embed.js';
      (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
      })();
    </script>
    <noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
    <a href="http://disqus.com" class="dsq-brlink">blog comments powered by <span class="logo-disqus">Disqus</span></a>
  </section>
</article>
]]></description>
    <pubDate>Fri, 05 Apr 2013 00:00:00 UT</pubDate>
    <guid>http://blog.fantasticsid.com/posts/2013-04-05-cpp-template.html</guid>
</item>
<item>
    <title>2013新年计划</title>
    <link>http://blog.fantasticsid.com/posts/2013-01-01-2013-resolutions.html</link>
    <description><![CDATA[<article>
  <header>
    <div class="content">
      <div class="nav">
        <a href="/posts.html">← All posts</a>
      </div>
    <p class="meta"><time class="timeago" datetime="2013-01-01" pubdate>2013-01-01</time></p>
    <h1>2013新年计划</h1>
    </header>
  <section>
    <p>今年简单一点</p>
<pre><code>深入研究Haskell, wiki上的页面基本都要有个了解, 能用Haskell写高效后台应用.

深入研究C++, 熟练应用模版, C++ 11的高级特性.

看CLRS, PFDS刷一下各种OJ, interviewstreet什么的.
</code></pre>
<p>去年的完成情况, 按照0-5完成进度打分:</p>
<pre><code>定义新自己 2

发布几个iOS应用 3

看完Haskell的几本书, 写一个解释器/比较大的应用 1

做机器学习的应用 0

概率论, 组合数学, 分析, 线性代数各书习题重新做一遍 0

搞个小提琴学 4

练耳不靠谱 2

要看的书:

&lt;&lt;Learn you a haskell for great good&gt;&gt; 5

&lt;&lt;Real world haskell&gt;&gt; 4

&lt;&lt;Programming in haskell&gt;&gt; 0

&lt;&lt;The Haskell Road to Logic, Math and Programming&gt;&gt; 0

&lt;&lt;Purely functional data structures&gt;&gt; 2

&lt;&lt;Pearls of functional algorithm design&gt;&gt; 0

&lt;&lt;Introduction to algorithms&gt;&gt; 0

&lt;&lt;Algorithms&gt;&gt; 0

&lt;&lt;Structure and interpretation of computer programs&gt;&gt; 1

&lt;&lt;Jazz theory book&gt;&gt; 0

&lt;&lt;Javascript the good parts&gt;&gt; 4

&lt;&lt;Clojure in action&gt;&gt; 0

&lt;&lt;The joy of clojure&gt;&gt; 4

&lt;&lt;Practical clojure&gt;&gt; 1

&lt;&lt;Programming clojure&gt;&gt; 1

&lt;&lt;Godel Escher Bach - an Eternal Golden Braid&gt;&gt; 0
</code></pre>
<p>发现去年又不知道活在哪个次元了.</p>
  </section>

  <section id="comment">

    <div id="disqus_thread"></div>
    <script type="text/javascript">
      /* * * CONFIGURATION VARIABLES: EDIT BEFORE PASTING INTO YOUR WEBPAGE * * */
      var disqus_shortname = 'fantasticsidtheblog'; // required: replace example with your forum shortname

      /* * * DON'T EDIT BELOW THIS LINE * * */
      (function() {
      var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
      dsq.src = 'http://' + disqus_shortname + '.disqus.com/embed.js';
      (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
      })();
    </script>
    <noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
    <a href="http://disqus.com" class="dsq-brlink">blog comments powered by <span class="logo-disqus">Disqus</span></a>
  </section>
</article>
]]></description>
    <pubDate>Tue, 01 Jan 2013 00:00:00 UT</pubDate>
    <guid>http://blog.fantasticsid.com/posts/2013-01-01-2013-resolutions.html</guid>
</item>
<item>
    <title>App idea - Unitask</title>
    <link>http://blog.fantasticsid.com/posts/2012-04-03-unitask.html</link>
    <description><![CDATA[<article>
  <header>
    <div class="content">
      <div class="nav">
        <a href="/posts.html">← All posts</a>
      </div>
    <p class="meta"><time class="timeago" datetime="2012-04-03" pubdate>2012-04-03</time></p>
    <h1>App idea - Unitask</h1>
    </header>
  <section>
    <p>这个和前面一篇<a href="/posts/2012-02-02-app-idea.html">Motivated App</a>的想法有点类似.</p>
<div>
<img src="/images/unitask1.jpeg" title="Unitask" />
</div>

<div>
<img src="/images/unitask2.jpeg" title="Unitask" />
</div>

<div>
<img src="/images/unitask3.jpeg" title="Unitask" />
</div>


  </section>

  <section id="comment">

    <div id="disqus_thread"></div>
    <script type="text/javascript">
      /* * * CONFIGURATION VARIABLES: EDIT BEFORE PASTING INTO YOUR WEBPAGE * * */
      var disqus_shortname = 'fantasticsidtheblog'; // required: replace example with your forum shortname

      /* * * DON'T EDIT BELOW THIS LINE * * */
      (function() {
      var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
      dsq.src = 'http://' + disqus_shortname + '.disqus.com/embed.js';
      (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
      })();
    </script>
    <noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
    <a href="http://disqus.com" class="dsq-brlink">blog comments powered by <span class="logo-disqus">Disqus</span></a>
  </section>
</article>
]]></description>
    <pubDate>Tue, 03 Apr 2012 00:00:00 UT</pubDate>
    <guid>http://blog.fantasticsid.com/posts/2012-04-03-unitask.html</guid>
</item>
<item>
    <title>iPad上的画图软件: paper</title>
    <link>http://blog.fantasticsid.com/posts/2012-04-02-paper-ipad.html</link>
    <description><![CDATA[<article>
  <header>
    <div class="content">
      <div class="nav">
        <a href="/posts.html">← All posts</a>
      </div>
    <p class="meta"><time class="timeago" datetime="2012-04-02" pubdate>2012-04-02</time></p>
    <h1>iPad上的画图软件: paper</h1>
    </header>
  <section>
    <p>我一直对有些blog上的涂鸦很感兴趣. 很多blog如xkcd中的图都是画在纸上然后扫描进电脑里的, 这个对于我来说又显得太麻烦了, 而且画画从来对我就是一件难事, 如何选颜色, 风格都是很难的问题.</p>
<p>其实我对涂鸦的要求很低, 只要能够起到说明问题, 让人一目了然就可以. 昨天发现了这个app: paper by fiftythree</p>
<p>这个app我想了下, 吸引我的原因主要是:</p>
<pre><code>
1. 选择少, 有几种画笔但是画笔不能选择粗细, 颜色只有固定的几种.

2. 这些选择的效果都不错. 不同画笔风格互相弥补, 仅有的几种颜色搭配很协调.
</code></pre>
<p>看来对我这样的业余用户来说, 在简洁性和功能性上选择前者更具有吸引力.</p>
<div>
<img src="/images/expopiano.jpg" title="exponential piano" />
</div>


  </section>

  <section id="comment">

    <div id="disqus_thread"></div>
    <script type="text/javascript">
      /* * * CONFIGURATION VARIABLES: EDIT BEFORE PASTING INTO YOUR WEBPAGE * * */
      var disqus_shortname = 'fantasticsidtheblog'; // required: replace example with your forum shortname

      /* * * DON'T EDIT BELOW THIS LINE * * */
      (function() {
      var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
      dsq.src = 'http://' + disqus_shortname + '.disqus.com/embed.js';
      (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
      })();
    </script>
    <noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
    <a href="http://disqus.com" class="dsq-brlink">blog comments powered by <span class="logo-disqus">Disqus</span></a>
  </section>
</article>
]]></description>
    <pubDate>Mon, 02 Apr 2012 00:00:00 UT</pubDate>
    <guid>http://blog.fantasticsid.com/posts/2012-04-02-paper-ipad.html</guid>
</item>
<item>
    <title>App idea - Motivated</title>
    <link>http://blog.fantasticsid.com/posts/2012-02-02-app-idea.html</link>
    <description><![CDATA[<article>
  <header>
    <div class="content">
      <div class="nav">
        <a href="/posts.html">← All posts</a>
      </div>
    <p class="meta"><time class="timeago" datetime="2012-02-02" pubdate>2012-02-02</time></p>
    <h1>App idea - Motivated</h1>
    </header>
  <section>
    <p>Admit it, you are simply not as good a multitasker as a computer, and sometimes you’ve got moods that keep you distracted and unable to finish even one task at hand. Your productivity plumets and as soon as you realize this the negative feeling only adds to the problem you already have.</p>
<p>Enter Motivated, an iphone app that reminds you of the most important task you are supposed to finish.</p>
<p>Features:</p>
<ul>
<li>Only one task allowed at a time</li>
<li>Make commitment to your goal publicly</li>
<li>Schedule notifications, useful for example, to get yourself motivated at the start of day</li>
</ul>
  </section>

  <section id="comment">

    <div id="disqus_thread"></div>
    <script type="text/javascript">
      /* * * CONFIGURATION VARIABLES: EDIT BEFORE PASTING INTO YOUR WEBPAGE * * */
      var disqus_shortname = 'fantasticsidtheblog'; // required: replace example with your forum shortname

      /* * * DON'T EDIT BELOW THIS LINE * * */
      (function() {
      var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
      dsq.src = 'http://' + disqus_shortname + '.disqus.com/embed.js';
      (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
      })();
    </script>
    <noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
    <a href="http://disqus.com" class="dsq-brlink">blog comments powered by <span class="logo-disqus">Disqus</span></a>
  </section>
</article>
]]></description>
    <pubDate>Thu, 02 Feb 2012 00:00:00 UT</pubDate>
    <guid>http://blog.fantasticsid.com/posts/2012-02-02-app-idea.html</guid>
</item>
<item>
    <title>IELTS Quizme</title>
    <link>http://blog.fantasticsid.com/posts/2012-01-08-ielts-quizme.html</link>
    <description><![CDATA[<article>
  <header>
    <div class="content">
      <div class="nav">
        <a href="/posts.html">← All posts</a>
      </div>
    <p class="meta"><time class="timeago" datetime="2012-01-08" pubdate>2012-01-08</time></p>
    <h1>IELTS Quizme</h1>
    </header>
  <section>
    <p>发布了第一个iOS app, IELTS Quizme. 帮助准备考雅思的同学复习词汇, 对希望增加词汇的同学也有帮助.</p>
<p><a href="http://itunes.apple.com/us/app/ielts-quizme/id488641011">IELTS Quizme</a></p>
  </section>

  <section id="comment">

    <div id="disqus_thread"></div>
    <script type="text/javascript">
      /* * * CONFIGURATION VARIABLES: EDIT BEFORE PASTING INTO YOUR WEBPAGE * * */
      var disqus_shortname = 'fantasticsidtheblog'; // required: replace example with your forum shortname

      /* * * DON'T EDIT BELOW THIS LINE * * */
      (function() {
      var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
      dsq.src = 'http://' + disqus_shortname + '.disqus.com/embed.js';
      (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
      })();
    </script>
    <noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
    <a href="http://disqus.com" class="dsq-brlink">blog comments powered by <span class="logo-disqus">Disqus</span></a>
  </section>
</article>
]]></description>
    <pubDate>Sun, 08 Jan 2012 00:00:00 UT</pubDate>
    <guid>http://blog.fantasticsid.com/posts/2012-01-08-ielts-quizme.html</guid>
</item>
<item>
    <title>2012新年计划</title>
    <link>http://blog.fantasticsid.com/posts/2011-12-30-2012-resolutions.html</link>
    <description><![CDATA[<article>
  <header>
    <div class="content">
      <div class="nav">
        <a href="/posts.html">← All posts</a>
      </div>
    <p class="meta"><time class="timeago" datetime="2011-12-30" pubdate>2011-12-30</time></p>
    <h1>2012新年计划</h1>
    </header>
  <section>
    <pre><code>
定义新自己

发布几个iOS应用

看完Haskell的几本书, 写一个解释器/比较大的应用

做机器学习的应用

概率论, 组合数学, 分析, 线性代数各书习题重新做一遍

搞个小提琴学

练耳不靠谱

要看的书:

&lt;&lt;Learn you a haskell for great good&gt;&gt;

&lt;&lt;Real world haskell&gt;&gt;

&lt;&lt;Programming in haskell&gt;&gt;

&lt;&lt;The Haskell Road to Logic, Math and Programming&gt;&gt;

&lt;&lt;Purely functional data structures&gt;&gt;

&lt;&lt;Pearls of functional algorithm design&gt;&gt;

&lt;&lt;Introduction to algorithms&gt;&gt;

&lt;&lt;Algorithms&gt;&gt;

&lt;&lt;Structure and interpretation of computer programs&gt;&gt;

&lt;&lt;Jazz theory book&gt;&gt;

&lt;&lt;Javascript the good parts&gt;&gt;

&lt;&lt;Clojure in action&gt;&gt;

&lt;&lt;The joy of clojure&gt;&gt;

&lt;&lt;Practical clojure&gt;&gt;

&lt;&lt;Programming clojure&gt;&gt;

&lt;&lt;Godel Escher Bach - an Eternal Golden Braid&gt;&gt;
</code></pre>
  </section>

  <section id="comment">

    <div id="disqus_thread"></div>
    <script type="text/javascript">
      /* * * CONFIGURATION VARIABLES: EDIT BEFORE PASTING INTO YOUR WEBPAGE * * */
      var disqus_shortname = 'fantasticsidtheblog'; // required: replace example with your forum shortname

      /* * * DON'T EDIT BELOW THIS LINE * * */
      (function() {
      var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
      dsq.src = 'http://' + disqus_shortname + '.disqus.com/embed.js';
      (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
      })();
    </script>
    <noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
    <a href="http://disqus.com" class="dsq-brlink">blog comments powered by <span class="logo-disqus">Disqus</span></a>
  </section>
</article>
]]></description>
    <pubDate>Fri, 30 Dec 2011 00:00:00 UT</pubDate>
    <guid>http://blog.fantasticsid.com/posts/2011-12-30-2012-resolutions.html</guid>
</item>
<item>
    <title>Arrow定理 - 没有合理的选举!</title>
    <link>http://blog.fantasticsid.com/posts/2011-09-04-arrowstheorem.html</link>
    <description><![CDATA[<article>
  <header>
    <div class="content">
      <div class="nav">
        <a href="/posts.html">← All posts</a>
      </div>
    <p class="meta"><time class="timeago" datetime="2011-09-04" pubdate>2011-09-04</time></p>
    <h1>Arrow定理 - 没有合理的选举!</h1>
    </header>
  <section>
    <p><a href="http://en.wikipedia.org/wiki/Arrow's_impossibility_theorem">Arrow定理</a>可能是博弈论中最著名的定理之一了, 还记得Rudolf在上课时用了整整1节多课证明了这个定理. 同时它的结论绝对能够吸引任何一个人, 难道现存的所有选举制度都是不合理的吗? 当然, 定理是有条件的, arrow定理也不例外, 但是arrow定理的条件让人觉得再自然不过了:</p>
<p>首先设想, 一个选举中有多于3个候选人, {A, B, C…}, N个选民. 每一个选民对候选人给出一个排名(两两可比, 传递), 例如, B &gt; A &gt; C . 而一个选举制度是一个函数F, 它把N个选民对候选人的排名映射到一个“全社会”的排名.</p>
<p>Arrow定理的条件:</p>
<pre><code> 1.  Unanimity(全票通过),
 就是说, 如果所有选民觉得A &gt; B, 那么对选举的结果也有A &gt; B

 2.  Independence of irrelevant alternatives(IIA, 不相关候选者独立性),
 就是, 选举结果中, A和B的相对次序只和A, B在所有选民的排名中的次序相关, 而和C的排名是无关的

 3.  No dictatorship(没有独裁),
 就是, 不存在一个选民i, 他的排名决定了任何一对候选人A, B在选举结果中的排名.</code></pre>
<p>以上条件我们通常都认为是一个公平选举制度所必须具有的性质, 但是arrow定理告诉我们, 同时满足这3个条件的选举制度是不存在的! 或者说, 如果要满足条件1, 2, 那么这个选举中就存在一个独裁的选民.</p>
<p>首先我们来看一个结论: 如果每一个选民都把候选人B排列在最前, 或者最后面, 那么选举结果也将会把B放在排名最前或者最后, 而不是中间的某一个位置.</p>
<p>其实这个结论就已经让我们觉得这个选举是不公平的, 因为假如有一半的选民认为B是最好的, 另外一半认为B是最差的, 那么理想的选举似乎应该把B放在排名中间某个位置, 而不是放在最好或者最差的排名上.</p>
<p>证明:</p>
<p>假设选举结果中B不是在最好或者最差的位置上, 即存在A, C, 使得A &gt; B &gt; C, 那么假设我们现在在每一个选民的排名中, 将C移动到A之前.</p>
<pre><code> 根据条件Unanimity, 选举结果应该有C &gt; A.

 但是注意在每个选民的排名中, 由于B是在排名两端之一的,
 所以这个移动并不会影响BC, AB之间的排名,

 于是根据条件IIA, 选举结果中BC, AB的排名应该不受影响,
 于是A &gt; B, B &gt; C仍然应该成立. 由于选举结果是两两可比并且传递的, 于是有A &gt; C.</code></pre>
<p>这是个矛盾, 因此就证明了, 选举结果中, B一定也是在排名的最前或者最后, 而不是中间某个位置. 待续…</p>
  </section>

  <section id="comment">

    <div id="disqus_thread"></div>
    <script type="text/javascript">
      /* * * CONFIGURATION VARIABLES: EDIT BEFORE PASTING INTO YOUR WEBPAGE * * */
      var disqus_shortname = 'fantasticsidtheblog'; // required: replace example with your forum shortname

      /* * * DON'T EDIT BELOW THIS LINE * * */
      (function() {
      var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
      dsq.src = 'http://' + disqus_shortname + '.disqus.com/embed.js';
      (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
      })();
    </script>
    <noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
    <a href="http://disqus.com" class="dsq-brlink">blog comments powered by <span class="logo-disqus">Disqus</span></a>
  </section>
</article>
]]></description>
    <pubDate>Sun, 04 Sep 2011 00:00:00 UT</pubDate>
    <guid>http://blog.fantasticsid.com/posts/2011-09-04-arrowstheorem.html</guid>
</item>
<item>
    <title>一点博弈论趣题</title>
    <link>http://blog.fantasticsid.com/posts/2011-08-06-game-theory.html</link>
    <description><![CDATA[<article>
  <header>
    <div class="content">
      <div class="nav">
        <a href="/posts.html">← All posts</a>
      </div>
    <p class="meta"><time class="timeago" datetime="2011-08-06" pubdate>2011-08-06</time></p>
    <h1>一点博弈论趣题</h1>
    </header>
  <section>
    <p>回顾快要结束的研究生生活, 发现真正带给我学习快乐的并不是研究. 虽然机器学习, 计算机视觉都是非常有趣的方向, 可是由于自己积累太少, 要想真正体会到研究的快乐还是比较难, 尤其是作学术讲究求新立异, 现在看来一年的确是不够的. 事实上我向来觉得, 如果我们普通人能够掌握到19世纪初左右的数学, 科学知识, 那么也已经相当牛了. 而推进人类认知的任务, 就交给PHD先生/女士们了. 而我本来就没有一颗献身科学的心, 当然如果有的话, 也不会选择计算机科学, 一定是数学或者物理. 所以说学术这条路, 事实上已经在6年前被我亲手斩断了.</p>
<p>总而言之, 自己创新能力还是不够, 更善于接受一些别人做出的成果然后去评判是否有趣有用值得读. 比如说, 研究生阶段80%的课程都是断然的水课. 剩下的不水的课中, 掐指一算, 也就只有Rudolf Fleischer老师的算法博弈论和阚海斌老师的图论课属于有趣的了. 这几天觉得应该把这些内容整理一下积累起来才不算浪费. 这应该是一系列关于博弈论或者图论的文章之一, 记录一些有趣的, 有启示的结论, 证明等等.</p>
<p>相信很多人听说博弈论都是从囚徒困境开始的. 用最简单的话来说, 囚徒A, B分别有承认他们的犯罪或者抵赖两种选择, 而这个“游戏”的设计使得他们中任何一个人, 无论另外一个囚徒的选择是如何的, 对于自己来说, 选择承认犯罪总是更好的选择. 因此这个游戏的最终结果就是, A, B都承认犯罪, 双双入狱坐牢2年, 而如果他们知道合作都不承认犯罪, 那么最好的结果是他们只需坐牢1年.</p>
<pre><code>        A承认    A抵赖


 B承认 都坐牢2年 A坐牢5年


 B抵赖 B坐牢5年 都坐牢1年</code></pre>
<p>事实上, 一种更好的说法是, A,B同时抵赖在这个游戏中并不是一个纳什均衡点, 即在没有合作的情况下, 有参与者会从这个“大家都抵赖”的点选择其他的做法, 因此游戏最终没有停留在这个点上. 而且在囚徒困境中, 每一个参与者都有一个<a href="http://en.wikipedia.org/wiki/Dominant_strategy">“主导策略”</a>, 也就是说无论对手如何选择, 选择抵赖总是最好的策略. 这种情况下游戏很容易就会到达一个纳什均衡点.</p>
<p>关于纳什均衡点有很多有趣的性质准备在后续的文章中详细说说. 我们再来看一些有趣的博弈论例子.</p>
<p>Braess悖论</p>
<p>考虑A, B两座城市之间的高速公路:</p>
<div>
<img src="/images/braess.png" title="braess" />
</div>

<p>假定走A-X以及Y-B这2条路消耗的时间是T/100 , 其中T是路上的车辆数, 而A-Y和X-B上消耗的时间为常数45分钟. 现在如果有4000辆车, 那么容易得到, 在2条路径A-X-B和A-Y-B上分别有2000辆车时, 这个游戏达到了平衡, 大家都会花费65分钟在路上.</p>
<p>现在我们试图建造一条超高速高架, 连接X-Y, 而且从X到Y的时间可以忽略不计.</p>
<div>
<img src="/images/braess2.png" title="braess" />
</div>

<p>这时, 由于司机考虑到, T/100最多为40, 因此他们会毫不犹豫得选择A-X, 而同样的道理, 由于X-Y的时间消耗为0, 他们在到达X之后会选择由超高速高架到达Y, 继而再花40分钟到达B. 因为每一个司机都是如此考虑的, 所以在这种添加了一条超高速公路的情况下, 游戏最终会稳定在所有人都选择A-X-Y-B的路径, 花费80分钟从A到达B. 而我们之前看到, 在没有超高速公路的情况下, 最佳路径花费只需65分钟. 悖论出现了, 额外花钱建造的超高速公路反而使得大家花费在路上的时间增加了!</p>
<p>事实上博弈论出现得比我们想象的更加频繁, 比如google adwords的第二价格竞标, 比如近两年很火的HFT, 股票市场的博弈, 顺便提一下, 计算纳什平衡是非常难的问题(PPAD), 所以这可能也是即使有了计算机, 市场仍然难以把握的原因之一.</p>
<p>关于博弈论的书, &lt;&lt;Algorithmic game theory&gt;&gt;这本书写得的确不错, 内容也适合非数学/经济的同学读.</p>
  </section>

  <section id="comment">

    <div id="disqus_thread"></div>
    <script type="text/javascript">
      /* * * CONFIGURATION VARIABLES: EDIT BEFORE PASTING INTO YOUR WEBPAGE * * */
      var disqus_shortname = 'fantasticsidtheblog'; // required: replace example with your forum shortname

      /* * * DON'T EDIT BELOW THIS LINE * * */
      (function() {
      var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
      dsq.src = 'http://' + disqus_shortname + '.disqus.com/embed.js';
      (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
      })();
    </script>
    <noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
    <a href="http://disqus.com" class="dsq-brlink">blog comments powered by <span class="logo-disqus">Disqus</span></a>
  </section>
</article>
]]></description>
    <pubDate>Sat, 06 Aug 2011 00:00:00 UT</pubDate>
    <guid>http://blog.fantasticsid.com/posts/2011-08-06-game-theory.html</guid>
</item>
<item>
    <title>一图胜万言: fibonacci数列的一些结论的有趣证明</title>
    <link>http://blog.fantasticsid.com/posts/2011-07-07-fibonacci.html</link>
    <description><![CDATA[<article>
  <header>
    <div class="content">
      <div class="nav">
        <a href="/posts.html">← All posts</a>
      </div>
    <p class="meta"><time class="timeago" datetime="2011-07-07" pubdate>2011-07-07</time></p>
    <h1>一图胜万言: fibonacci数列的一些结论的有趣证明</h1>
    </header>
  <section>
    <p>看到一篇有趣的文章, 作者举了一个简单的出现了fibonacci数列的例子, 然后用这个例子证明了一系列关于fibonacci数列的结论. 这种巧妙的构造总是让人惊叹如果生活中处处都存在这样的“捷径”那该是多么精彩!</p>
<div>
<img src="/images/Screen-shot-2011-07-02-at-11.24.18-PM.png" title="蜂巢状路" />
</div>


<pre><code> 试想有两排蜂巢形状的路径, 假设现在你要从左上S处开始行走到达右下E处,
 每次只能向右走, 或者从上面的一格走到其右下的一格(从下面的一格走到其右上的一格),
 那么一共有多少不同的路径呢?</code></pre>
<p>容易证明, 这个路径数是一个fibonacci数, 作者给出了这个图清楚地表示了从S走到每一个格子不同的路径数.</p>
<div>
<img src="/images/Screen-shot-2011-07-02-at-11.32.48-PM.png" title="到达每一个格子的不同路径数" />
</div>

<p>容易证明, 路径数序列与fibonacci数列的初始值以及递归形式都是一样的, 这里走到第一个格子S只有F(1) = 1条路径.</p>
<p>现在可以开始证明一些关于fibonacci数列的结论了, 这些结论用其他方法当然也能够比较容易地得到, 但是用作者给出的这个例子, 我们将看到这些结论是多么的“显然”.</p>
<p>首先作者把这些蜂巢简化成了一些互联的点, 下面说明</p>
<blockquote>
<p>F(a) * F(b) + F(a+1) * F(b+1) = F(a+b+1)</p>
</blockquote>
<div>
<img src="/images/Screen-shot-2011-07-02-at-11.39.22-PM.png" title="第一种情况, 通过第a+1个" />
</div>



<div>
<img src="/images/Screen-shot-2011-07-02-at-11.48.00-PM.png" title="第二种情况, 不通过第a+1个点" />
</div>

<p>如图, 一个包含a+b+1个点的路, 总共有F(a+b+1)种不同的路径. 而这些路径可以分成两部分: 通过第a+1个点的以及没有通过第a+1个点的. 前者一共有: F(a+1) * F(b+1)条, 而后者则有F(a) * F(b)条.</p>
<p>于是, 结论不证自明.</p>
<p>如果这种方法只能证明一个结论, 那么也并不算神奇. 此文神奇之处正在于, 这种fibonacci数列的呈现方式帮助作者直观地证明了一系列命题, 比如:</p>
<p>记P(N)为将整数N表示为1和2的有序数列之和, 证明P(N) = F(N+1)</p>
<p>当然, 这个结论用归纳法也是很容易证明的, 那么作者的这种表示方法是如何证明这个结论的呢?</p>
<div>
<img src="/images/Screen-shot-2011-07-07-at-4.43.15-PM.png" title="P(N) = F(N+1)" />
</div>


<p>如图, 可以发现12表示成的1和2之和, 每一种方式都一一对应了一种S-&gt;E的路径, 于是, 结论自然又不证自明.</p>
<p>还有一些诸如降N表示为1和2之和, 不考虑顺序有多少种方式? (不需要用文章的方法..) 用1x2的多米诺平铺2*n的地板有多少种方式等等的问题, 都是不错的等菜题.</p>
<p>有兴趣的话可以通读<a href="http://www.jamestanton.com/images/2011/06/Fibonacci-Surprises.pdf" target="_blank">全文</a>, 看看作者如何证明其他有趣结论.</p>
  </section>

  <section id="comment">

    <div id="disqus_thread"></div>
    <script type="text/javascript">
      /* * * CONFIGURATION VARIABLES: EDIT BEFORE PASTING INTO YOUR WEBPAGE * * */
      var disqus_shortname = 'fantasticsidtheblog'; // required: replace example with your forum shortname

      /* * * DON'T EDIT BELOW THIS LINE * * */
      (function() {
      var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
      dsq.src = 'http://' + disqus_shortname + '.disqus.com/embed.js';
      (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
      })();
    </script>
    <noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
    <a href="http://disqus.com" class="dsq-brlink">blog comments powered by <span class="logo-disqus">Disqus</span></a>
  </section>
</article>
]]></description>
    <pubDate>Thu, 07 Jul 2011 00:00:00 UT</pubDate>
    <guid>http://blog.fantasticsid.com/posts/2011-07-07-fibonacci.html</guid>
</item>

    </channel> 
</rss>
