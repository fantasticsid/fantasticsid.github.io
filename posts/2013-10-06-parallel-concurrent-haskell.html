<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <title>Parallel and Concurrent Programming in Haskell 笔记 | fantasticsid</title>
    <meta name="author" content="fantasticsid">
    <meta name="description" content="Parallel and Concurrent Programming in Haskell 笔记">
    <meta name="keywords" content="mathematics, computer science, haskell, clojure, scala, erlang, C++, python, music">
    <meta name="viewport" content="width=device-width, initial-scale=1">

    <link rel="stylesheet" type="text/css" href="../stylesheets/bootstrap.min.css">
    <link rel="stylesheet" type="text/css" href="../stylesheets/bootstrap-theme.min.css">
    <link rel="stylesheet" type="text/css" href="../stylesheets/styles.css">

    <link rel="shortcut icon" type="image/png" href="../images/favicon.png">
  </head>


  <body class="post">
    <nav class="navbar navbar-default navbar-fixed-top" role="navigation">
      <div class="container">
        <!-- Brand and toggle get grouped for better mobile display -->
        <div class="navbar-header">
          <button type="button" class="navbar-toggle" data-toggle="collapse" data-target="#bs-example-navbar-collapse-1">
            <span class="sr-only">Toggle navigation</span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
          </button>
          <a class="navbar-brand" href="../">The blog</a>
        </div>

        <!-- Collect the nav links, forms, and other content for toggling -->
        <div class="collapse navbar-collapse" id="bs-example-navbar-collapse-1">
          <ul class="nav navbar-nav">
            <!-- <li class="dropdown"> -->
            <!--   <a href="#" class="dropdown-toggle" data-toggle="dropdown" title="Our Collection of Templates &amp; Themes" aria-expanded="false">Themes <b class="caret"></b></a> -->
            <!--   <ul class="dropdown-menu"> -->
            <!--     <li> -->
            <!--       <a href="/template-categories/all"><i class="fa fa-globe fa-fw"></i> All Templates &amp; Themes</a> -->
            <!--     </li> -->
            <!--     <li> -->
            <!--       <a href="/template-categories/popular"><i class="fa fa-star fa-fw"></i> Most Popular</a> -->
            <!--     </li> -->
            <!--     <li> -->
            <!--       <a href="/buy-bootstrap-templates"><i class="fa fa-shopping-cart fa-fw"></i> Buy Bootstrap Templates</a> -->
            <!--     </li> -->
            <!--     <li class="divider"></li> -->
            <!--     <li class="dropdown-header"> -->
            <!--       Template &amp; Theme Categories: -->
            <!--     </li> -->
            <!--     <li> -->
            <!--       <a href="/template-categories/admin-dashboard">Admin and Dashboard</a> -->
            <!--     </li> -->
            <!--     <li> -->
            <!--       <a href="/template-categories/full-websites">Full Websites</a> -->
            <!--     </li> -->
            <!--     <li> -->
            <!--       <a href="/template-categories/landing-pages">Landing Pages</a> -->
            <!--     </li> -->
            <!--     <li> -->
            <!--       <a href="/template-categories/one-page">One Page Websites</a> -->
            <!--     </li> -->
            <!--     <li> -->
            <!--       <a href="/template-categories/portfolios">Portfolios</a> -->
            <!--     </li> -->
            <!--     <li> -->
            <!--       <a href="/template-categories/blogs">Blogs</a> -->
            <!--     </li> -->
            <!--     <li> -->
            <!--       <a href="/template-categories/ecommerce">Ecommerce</a> -->
            <!--     </li> -->
            <!--     <li> -->
            <!--       <a href="/template-categories/unstyled">Unstyled Starter Templates</a> -->
            <!--     </li> -->
            <!--     <li> -->
            <!--       <a href="/template-categories/navigation-menus">Navigation and Navbars</a> -->
            <!--     </li> -->
            <!--   </ul> -->
            <!-- </li> -->
            <li>
              <a href="../" title="Home">Home</a>
            </li>
            <!-- <li class="dropdown"> -->
            <!--   <a href="#" class="dropdown-toggle" data-toggle="dropdown" title="Bootstrap Related Resources" aria-expanded="false">Resources <b class="caret"></b></a> -->
            <!--   <ul class="dropdown-menu"> -->
            <!--     <li> -->
            <!--       <a href="/bootstrap-resources"><i class="fa fa-list fa-fw"></i> Bootstrap Resources List</a> -->
            <!--     </li> -->
            <!--     <li> -->
            <!--       <a href="/showcase"><i class="fa fa-desktop fa-fw"></i> Start Bootstrap Showcase</a> -->
            <!--     </li> -->
            <!--   </ul> -->
            <!-- </li> -->
            <li>
              <a href="../posts.html" title="Posts">Posts</a>
            </li>
            <li>
              <a href="../about.html" title="About">About</a>
            </li>
          </ul>
          <!-- <ul class="nav navbar-nav navbar-right"> -->
          <!--   <li class="dropdown"> -->
          <!--     <a href="#" class="dropdown-toggle" data-toggle="dropdown" title="Premium Bootstrap Themes &amp; Templates"><i class="fa fa-star text-yellow"></i> Premium <b class="caret"></b></a> -->
          <!--     <ul class="dropdown-menu"> -->
          <!--       <li> -->
          <!--         <a href="/bootstrap-design-services"><i class="fa fa-fw fa-paint-brush"></i> Custom Bootstrap Design Services</a> -->
          <!--       </li> -->
          <!--       <li> -->
          <!--         <a href="https://wrapbootstrap.com/?ref=StartBootstrap"><i class="fa fa-fw fa-shopping-cart"></i> WrapBootstrap - Premium Bootstrap Themes</a> -->
          <!--       </li> -->
          <!--     </ul> -->
          <!--   </li> -->
          <!-- </ul> -->
        </div>
        <!-- /.navbar-collapse -->
      </div>
      <!-- /.container -->
    </nav>
    
    <div id="bodywrapper">

      <div class="container">
        <div class="container">
  <div class="row">
    <div class="col-md-2">
    </div>
    <div class="col-md-8">
  <article>
  <header>
    <div class="content">
    <h1 class="text-center">Parallel and Concurrent Programming in Haskell 笔记</h1>
    </header>
  <section>
    <ol style="list-style-type: decimal">
<li>Introduction</li>
</ol>
<p>介绍了并行计算和多线程计算的概念和区别. Haskell里面并行计算是有确定执行结果的(deterministic), 并且提供了Eval Monad, Par Monad, 以及如repa和accelerate等库. 而多线程计算则有MVar, STM, actor等的支持.</p>
<ol start="2" style="list-style-type: decimal">
<li>Basic Parallelism: The Eval Monad</li>
</ol>
<p>Eval Monad. 既然是Monad, 那么从计算的角度看, 应该是应该是包含了对一个普通计算如何并行的一个Context. 所以构造Eval Monad实例的过程就可以看成是构造并行Context的过程.</p>
<p>Haskell中的表达式都是惰性求值的, 程序当中的表达式运行时的表示也是通过thunk实现的. 即使是1 + 2这样简单的表达式, 也是惰性的.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">Prelude</span><span class="fu">&gt;</span> <span class="kw">let</span> x <span class="fu">=</span> <span class="dv">1</span> <span class="fu">+</span> <span class="dv">2</span>
<span class="dt">Prelude</span><span class="fu">&gt;</span> <span class="fu">:</span>sprint x
x <span class="fu">=</span> _
<span class="dt">Prelude</span><span class="fu">&gt;</span></code></pre></div>
<p>Haskell的seq函数将一个表达式求值到WHNF (weak head normal form), 而WHNF粗略地讲, 就是一个数据结构的constructor.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">Prelude</span><span class="fu">&gt;</span> <span class="kw">let</span> swap (x, y) <span class="fu">=</span> (y, x)
<span class="dt">Prelude</span><span class="fu">&gt;</span> <span class="kw">let</span> x <span class="fu">=</span> <span class="dv">1</span> <span class="fu">+</span> <span class="dv">2</span>
<span class="dt">Prelude</span><span class="fu">&gt;</span> <span class="kw">let</span> z <span class="fu">=</span> swap(x, x <span class="fu">+</span> <span class="dv">1</span>)
<span class="dt">Prelude</span><span class="fu">&gt;</span> <span class="fu">:</span>sprint z
z <span class="fu">=</span> _
<span class="dt">Prelude</span><span class="fu">&gt;</span> seq z ()
()
<span class="dt">Prelude</span><span class="fu">&gt;</span> <span class="fu">:</span>sprint z
z <span class="fu">=</span> (_,_)
<span class="dt">Prelude</span><span class="fu">&gt;</span></code></pre></div>
<p>这里表达式z在seq之后, 被evaluate到第一个constructor, 也就是(,)</p>
<p>一个更复杂的例子, 考虑map函数:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">map<span class="ot"> ::</span> (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> [a] <span class="ot">-&gt;</span> [b]
map f [] <span class="fu">=</span> []
map f (x<span class="fu">:</span>xs) <span class="fu">=</span> f x <span class="fu">:</span> map f xs</code></pre></div>
<p>这里如果有表达式:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">Prelude</span><span class="fu">&gt;</span> <span class="kw">let</span> xs <span class="fu">=</span> map (<span class="fu">+</span> <span class="dv">1</span>) [<span class="dv">1</span><span class="fu">..</span><span class="dv">10</span>]
<span class="dt">Prelude</span><span class="fu">&gt;</span> <span class="fu">:</span>sprint xs
xs <span class="fu">=</span> _
<span class="dt">Prelude</span><span class="fu">&gt;</span> seq xs ()
()
<span class="dt">Prelude</span><span class="fu">&gt;</span> <span class="fu">:</span>sprint xs
xs <span class="fu">=</span> _ <span class="fu">:</span> _
<span class="dt">Prelude</span><span class="fu">&gt;</span></code></pre></div>
<p>这里表达式xs进行seq求值之后, 只求值到第一个constructor, 也就是(:)</p>
<p>Eval Monad</p>
<p>和State Monad等类似, Eval Monad有一些基本的combinator</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">runEval ::</span> <span class="dt">Eval</span> a <span class="ot">-&gt;</span> a

<span class="ot">rpar ::</span> a <span class="ot">-&gt;</span> <span class="dt">Eval</span> a
<span class="ot">rseq ::</span> a <span class="ot">-&gt;</span> <span class="dt">Eval</span> a</code></pre></div>
<p>关于rpar, rseq有一些管用用法, 可以精准控制是否等待表达式求值完成后返回. (rpar表示可以并行, 而rseq等待表达式完成后才返回.) 而最常用的一个用法是:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">runEval <span class="fu">$</span> <span class="kw">do</span>
  a <span class="ot">&lt;-</span> rpar (f x)
  b <span class="ot">&lt;-</span> rpar (f y)
  rseq a
  rseq b
  return (a, b)</code></pre></div>
<p>这种用法中, f x和f y并行求值, 但是整个表达式(a, b)在这两个运算完成后才返回.</p>
<p>并行数独, 这个例子演示了如何用Eval Monad并行计算若干个数独问题的解.</p>
<p>值得注意的是, 代码中:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">solutions <span class="fu">=</span> runEval <span class="fu">$</span> <span class="kw">do</span>
              as' <span class="ot">&lt;-</span> rpar (force (map solve as))
              bs' <span class="ot">&lt;-</span> rpar (force (map solve bs))
              rseq as'
              rseq bs'
              return (as' <span class="fu">++</span> bs')</code></pre></div>
<p>这里如果省略掉了force, 那么map solve as只会求值到WHNF, 也就是第一个(:)就结束了.</p>
<p>这事实上会导致返回的表达式在最终计算数独解法个数的时候:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">print (length (filter isJust solutions))</code></pre></div>
<p>才被真正的计算出来. 这样就失去了用Eval Monad进行并行化的意义了.</p>
<p>而force将一个表达式求值为NF (normal form).</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">force ::</span> <span class="dt">NFData</span> a <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> a</code></pre></div>
<p>parMap: 为了增加并行的粒度</p>
<p>它的定义十分直接:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">parMap ::</span> (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> [a] <span class="ot">-&gt;</span> <span class="dt">Eval</span> [b]
parMap f [] <span class="fu">=</span> return
parMap f (a<span class="fu">:</span>as) <span class="fu">=</span> <span class="kw">do</span>
  b <span class="ot">&lt;-</span> rpar (f a)
  bs <span class="ot">&lt;-</span> parMap f as
  return (b<span class="fu">:</span>bs)</code></pre></div>
<p>每一次使用rpar的时候, 我们都在创建spark, 这些spark在系统的一个spark池中. 而它们最终可能有多种结果:</p>
<ul>
<li>overflowed</li>
</ul>
<p>spark太多, spark pool放不下</p>
<ul>
<li>dud</li>
</ul>
<p>表达式已经被求值</p>
<ul>
<li>GC’d</li>
</ul>
<p>程序运行的时候并没有用到这个表达式</p>
<ul>
<li>fizzled</li>
</ul>
<p>表达式创建的时候并没有被求值, 但是之后程序的其余部分对其进行了求值. 这些spark也会被清理掉</p>
<p>在sudoku的例子当中, 程序开始时读入数据分割行的部分不能并行化. 这也是并行加速度不能无限制上升的原因之一. (Amdahl’s law) 另一方面, Haskell的惰性求值使得数据一旦部分读入, 就可以开始处理, 而不必等到整个列表都生成以后才开始计算.</p>
<p>Deepseq</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">force ::</span> <span class="dt">NFData</span> a <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> a</code></pre></div>
<p>force函数使得一个表达式求值为normal form.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">class</span> <span class="dt">NFData</span> a <span class="kw">where</span>
<span class="ot">  rnf ::</span> a <span class="ot">-&gt;</span> ()
  rnf a <span class="fu">=</span> a <span class="ot">`seq`</span> ()</code></pre></div>
<p>性能上, 对于一个表达式/数据结构, 求值到normal form通常要遍历整个结构, 所以复杂度是O(n)的, n是数据结构的大小. 而如果是seq, 则是常数复杂度的操作.</p>
<ol start="7" style="list-style-type: decimal">
<li>Basic Concurrency: Threads and MVars</li>
</ol>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">forkIO ::</span> <span class="dt">IO</span> () <span class="ot">-&gt;</span> <span class="dt">IO</span> <span class="dt">ThreadId</span></code></pre></div>
<p>这个API产生的是一个lightweight thread. 如果要系统线程, 则要用forkOS.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">import </span><span class="dt">Control.Concurrent</span>
<span class="kw">import </span><span class="dt">Control.Monad</span>
<span class="kw">import </span><span class="dt">System.IO</span>

main <span class="fu">=</span> <span class="kw">do</span>
  hSetBuffering stdout <span class="dt">NoBuffering</span>
  forkIO (replicateM_ <span class="dv">10</span> (putChar <span class="ch">'A'</span> <span class="fu">&gt;&gt;</span> threadDelay <span class="dv">1000000</span>))
  replicateM_ <span class="dv">10</span> (putChar <span class="ch">'B'</span> <span class="fu">&gt;&gt;</span> threadDelay <span class="dv">1000000</span>)</code></pre></div>
<p>这里使用threadDelay的原因是threaDelay是合适Haskell lightweight thread的API. 如果使用sleep, 因为GHC的内部时钟是使用操作系统的signal的, 会导致sleep的系统调用立刻返回. 而且即使禁止了RTS timer, 也必须在OS thread中调用sleep, 否则会阻塞其他的线程. threadDelay就不会有这些限制. 我的理解是, 只有和原生的库互操作时, 才可能需要用到sleep.</p>
<p>Haskell的线程默认情况下, main返回的时候就会结束. 也就是说他们默认都是daemon thread, 除了main所在的线程.</p>
<p>Haskell线程之间通讯可以用MVar</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">MVar</span> a
<span class="ot">newEmptyMVar ::</span> <span class="dt">IO</span> (<span class="dt">MVar</span> a)
<span class="ot">newMVar ::</span> a <span class="ot">-&gt;</span> <span class="dt">IO</span> (<span class="dt">MVar</span> a)
<span class="ot">takeMVar ::</span> <span class="dt">MVar</span> a <span class="ot">-&gt;</span> <span class="dt">IO</span> a
<span class="ot">putMVar ::</span> <span class="dt">MVar</span> a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">IO</span> ()</code></pre></div>
<p>这里MVar的API设计与后面的STM TVar的设计很像, 但是不能像TVar那样进行组合.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">main <span class="fu">=</span> <span class="kw">do</span>
  m <span class="ot">&lt;-</span> newEmptyMVar
  forkIO <span class="fu">$</span> putMVar m <span class="ch">'x'</span>
  r <span class="ot">&lt;-</span> takeMVar m
  print r</code></pre></div>
<p>MVar可以作为线程之间通讯的一种方法. 奇妙的是, 如果发生死锁, Haskell的runtime会检测到并且抛出异常.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">import </span><span class="dt">Control.Concurrent</span>

main <span class="fu">=</span> <span class="kw">do</span>
  m <span class="ot">&lt;-</span> newEmptyMVar
  takeMVar m</code></pre></div>
<p>所以总结下来, MVar可以看做是一个容量为1的channel, 可以用作线程间通讯, Haskell里面多个线程需要操作一个状态的时候, 可以把这个状态放在MVar里面, 这样takeMVar的时候就获得了状态并且对其加锁. putMVar的时候就更新了状态并且解锁, 当然, 也可以用MVar ()来代表一个锁.</p>
<p>MVar是Haskell里面并发数据结构的基本构件.</p>
<p>用MVar可以构建出一个logging service:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">Logger</span> <span class="fu">=</span> <span class="dt">Logger</span> (<span class="dt">MVar</span> <span class="dt">LogCommand</span>)
<span class="kw">data</span> <span class="dt">LogCommand</span> <span class="fu">=</span> <span class="dt">Message</span> <span class="dt">String</span> <span class="fu">|</span> <span class="dt">Stop</span> (<span class="dt">MVar</span> ())

<span class="ot">initLogger ::</span> <span class="dt">IO</span> <span class="dt">Logger</span>
initLogger <span class="fu">=</span> <span class="kw">do</span>
  m <span class="ot">&lt;-</span> newEmptyMVar
  <span class="kw">let</span> l <span class="fu">=</span> <span class="dt">Logger</span> m
  forkIO (logger l)
  return l

<span class="ot">logger ::</span> <span class="dt">Logger</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> ()
logger (<span class="dt">Logger</span> m) <span class="fu">=</span> loop
  <span class="kw">where</span>
    loop <span class="fu">=</span> <span class="kw">do</span>
    <span class="kw">case</span> cmd <span class="kw">of</span>
      <span class="dt">Message</span> msg <span class="ot">-&gt;</span> <span class="kw">do</span>
        putStrLn msg
        loop
      <span class="dt">Stop</span> s <span class="ot">-&gt;</span> <span class="kw">do</span>
        putStrLn <span class="st">&quot;logger: stop&quot;</span>
        putMVar s ()

<span class="ot">logMessage ::</span> <span class="dt">Logger</span> <span class="ot">-&gt;</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> ()
logMessage (<span class="dt">Logger</span> m) s <span class="fu">=</span> putMVar m (<span class="dt">Message</span> s)

<span class="ot">logStop ::</span> <span class="dt">Logger</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> ()
logStop (<span class="dt">Logger</span> m) <span class="fu">=</span> <span class="kw">do</span>
  s <span class="ot">&lt;-</span> newEmptyMVar
  putMVar m (<span class="dt">Stop</span> s)
  takeMVar s</code></pre></div>
<p>如果不用MVar, 以上的logging service用C++实现要用到Lock, Condition Variable. MVar可以作为Lock(takeMVar, putMVar), 也可以作为Condition Variable(takeMVar阻塞直到有线程putMVar).</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">type</span> <span class="dt">Name</span> <span class="fu">=</span> <span class="dt">String</span>
<span class="kw">type</span> <span class="dt">PhoneNumber</span> <span class="fu">=</span> <span class="dt">String</span>
<span class="kw">type</span> <span class="dt">PhoneBook</span> <span class="fu">=</span> <span class="dt">Map</span> <span class="dt">Name</span> <span class="dt">PhoneNumber</span>

<span class="kw">newtype</span> <span class="dt">PhoneBookState</span> <span class="fu">=</span> <span class="dt">PhoneBookState</span> (<span class="dt">MVar</span> <span class="dt">PhoneBook</span>)</code></pre></div>
<p>这里PhoneBookState可以在export的时候以抽象的形式出现.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">insert ::</span> <span class="dt">PhoneBookState</span> <span class="ot">-&gt;</span> <span class="dt">Name</span> <span class="ot">-&gt;</span> <span class="dt">Phone</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> ()
insert (<span class="dt">PhoneBookState</span> m) name number <span class="fu">=</span> <span class="kw">do</span>
  book <span class="ot">&lt;-</span> takeMVar m
  putMVar m (Map.insert name number book)

lookup<span class="ot"> ::</span> <span class="dt">PhoneBookState</span> <span class="ot">-&gt;</span> <span class="dt">Name</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> (<span class="dt">Maybe</span> <span class="dt">PhoneNumber</span>)
lookup (<span class="dt">PhoneBookState</span> m) name <span class="fu">=</span> <span class="kw">do</span>
  book <span class="ot">&lt;-</span> takeMVar m
  putMVar m book
  return (Map.lookup name book)</code></pre></div>
<p>这里注意, 我们的查找事实上是在takeMVar, putMVar之后发生. 这对于提高并发是一件好事. 当然, 这得益于Map是immutable data structure这一事实, 否则我们就必须在持有锁期间进行查找.</p>
<p>另外一点值得注意点是, putMVar m (Map.insert name number book)之后, m里面是一个thunk. 如果我们要减少space leak, 需要:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">putMVar m <span class="fu">$!</span> Map.insert name number book</code></pre></div>
<p>但是这样, Map.insert就要在putMVar之前执行完. 如果我们既要减少space leak, 又要使得持有锁的时间尽量短, 可以这样做:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">let</span> book' <span class="fu">=</span> Map.insert name number book
putMVar m book'
seq book' (return ())</code></pre></div>
<p>这里我感觉, 在极端情况下, putMVar之后, 在seq之前, 如果有其他线程获得这个MVar, 那么一致性就要依靠下面的thunk如何保持一致性了.</p>
<p>Unbounded Channels</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">Chan</span> a

<span class="ot">newChan ::</span> <span class="dt">IO</span> (<span class="dt">Chan</span> a)
<span class="ot">readChan ::</span> <span class="dt">Chan</span> a <span class="ot">-&gt;</span> <span class="dt">IO</span> a
<span class="ot">writeChan ::</span> <span class="dt">Chan</span> a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">IO</span> ()</code></pre></div>
<p>这里再次注意这个API和MVar, TVar的API之间的相似性.</p>
<p>Channel有相对复杂的结构:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">type</span> <span class="dt">Stream</span> a <span class="fu">=</span> <span class="dt">MVar</span> (<span class="dt">Item</span> a)
<span class="kw">data</span> <span class="dt">Item</span> a <span class="fu">=</span> <span class="dt">Item</span> a (<span class="dt">Stream</span> a)

<span class="kw">data</span> <span class="dt">Chan</span> a <span class="fu">=</span> <span class="dt">Chan</span> (<span class="dt">MVar</span> (<span class="dt">Stream</span> a)) (<span class="dt">MVar</span> (<span class="dt">Stream</span> a))</code></pre></div>
<p>Chan有两个MVar包含有两个Stream, 分别用作read pointer和write pointer.</p>
<p>创建一个新的Channel时, 只需要创建一个新的空Stream:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">newChan ::</span> <span class="dt">IO</span> (<span class="dt">Chan</span> a)
newChan <span class="fu">=</span> <span class="kw">do</span>
  hole <span class="ot">&lt;-</span> newEmptyMVar
  readVar <span class="ot">&lt;-</span> newMVar hole
  writeVar <span class="ot">&lt;-</span> newMVar hole
  return (<span class="dt">Chan</span> readVar writeVar)</code></pre></div>
<p>加入一个新元素, 我们需要构建一个新的Item, 然后让其后继结点指向当前write pointer, 然后调整write pointer. 这里和链表头插入新元素一样, 但是要注意concurrent safety:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">writeChan ::</span> <span class="dt">Chan</span> a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">IO</span> ()
writeChan (<span class="dt">Chan</span> _ writeVar) val <span class="fu">=</span> <span class="kw">do</span>
  newHole <span class="ot">&lt;-</span> newEmptyMVar
  oldHole <span class="ot">&lt;-</span> takeMVar writeVar
  putMVar oldHole (<span class="dt">Item</span> val newHole)
  putMVar writeVar newHole</code></pre></div>
<p>而拿出一个元素的代码:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">readChan ::</span> <span class="dt">Chan</span> a <span class="ot">-&gt;</span> <span class="dt">IO</span> a
readChan (<span class="dt">Chan</span> readVar _) <span class="fu">=</span> <span class="kw">do</span>
  stream <span class="ot">&lt;-</span> takeMVar readVar
  <span class="dt">Item</span> val tail <span class="ot">&lt;-</span> takeMVar stream
  putMVar readVar tail
  return val</code></pre></div>
<p>就writeChan, readChan来说, 代码并不复杂. 但是我们写的是concurrent code, 所以要注意是否线程安全.</p>
<p>当Channel是空的时候, readChan的第二个takeMVar会block, 直到有其他线程writeChan. 这里由于是空Channel, 所以read pointer和write pointer指向的是同一个MVar. 第一个线程阻塞时, 第二个线程可以putMVar, 从而第一个线程得以继续. 这里的极端情况, 即使是writeChan刚写入空Channel的第一个元素时, readChan读出第一个元素, 也是正确的. read pointer, write pointer保证了同时只有一个read, write操作(这里其实2个操作都是read write, 而不是read only, write only), 但是read, write可以同时存在.</p>
<p>对以上实现稍加修改, 可以得到multicast channel:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">dupChan ::</span> <span class="dt">Chan</span> a <span class="ot">-&gt;</span> <span class="dt">IO</span> (<span class="dt">Chan</span> a)
dupChan (<span class="dt">Chan</span> _ writeVar) <span class="fu">=</span> <span class="kw">do</span>
  hole <span class="ot">&lt;-</span> readMVar writeVar
  newReadVar <span class="ot">&lt;-</span> newMVar hole
  return (<span class="dt">Chan</span> newReadVar writeVar)

<span class="ot">readMVar ::</span> <span class="dt">MVar</span> a <span class="ot">-&gt;</span> <span class="dt">IO</span> a
readMVar m <span class="fu">=</span> <span class="kw">do</span>
  a <span class="ot">&lt;-</span> takeMVar m
  putMVar m a
  return a</code></pre></div>
<p>也就是, 新的channel和以前的channel共用了同一个write pointer, 但是read pointer仍然是分开的. 但是, 这里的一个问题是, 我们在实现readChan的时候使用了takeMVar stream. 这样, 指向这个Item的MVar就是空的了. 所以我们应该要做如下更改:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">readChan ::</span> <span class="dt">Chan</span> a <span class="ot">-&gt;</span> <span class="dt">IO</span> a
readChan (<span class="dt">Chan</span> readVar _) <span class="fu">=</span> <span class="kw">do</span>
  stream <span class="ot">&lt;-</span> takeMVar readVar
  <span class="dt">Item</span> val tail <span class="ot">&lt;-</span> readMVar stream
  putMVar readVar tail
  return val</code></pre></div>
<p>我们还可以继续丰富channel的API:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">unGetChan ::</span> <span class="dt">Chan</span> a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">IO</span> ()
unGetChan (<span class="dt">Chan</span> readVar _) val <span class="fu">=</span> <span class="kw">do</span>
  newReadEnd <span class="ot">&lt;-</span> newEmptyMvar
  readEnd <span class="ot">&lt;-</span> takeMVar readVar
  putMVar newReadEnd (<span class="dt">Item</span> val readEnd)
  putMVar readVar newReadEnd</code></pre></div>
<p>但是这个函数与readChan, 在channel为空的时候会死锁: readChan得到了readVar, 然后阻塞在stream上. 而unGetChan阻塞在readVar上. 理想情况下, 应该是unGetChan成功返回然后readChan也返回.</p>
<p>到这里, 我们发现, 使用MVar构建跟更高层的并发数据结构时需要考虑的情况变得越来越多了.</p>
<p>GHC保证, 只要没有线程一直获取一个MVar不释放, 那么在一个MVar上等待的线程不会永远阻塞. GHC会用一个queue保存一个MVar上等待的线程, 无论是putMVar还是takeMVar. 这里书上还提到了实现里的一个注意点: 当MVar上有值之后, 仅仅唤醒一个FIFO队列的第一个线程是不够的, 因为这时可能有另外一个线程正在运行从而获得这个MVar的控制权. 正确的做法是, 原子性地唤醒第一个等待的线程并且完成这个线程阻塞的MVar操作.</p>
<p>线程公平性</p>
<p>stdout这个文件描述符是用一个MVar表示的. 所以开始时, 两个不断输出字符的线程会交替输出, 原因是这两个线程交替在FIFO队列的队末进行等待.</p>
<p>这个实现的好处是: 多个线程阻塞在同一个MVar上时, 如果有一个putMVar/takeMVar使得这些线程能够继续, 则只有一个线程被unblock. 而MVar的公平性, 以及这个单个线程唤醒的特性是使得MVar没有被STM完全取代的原因.</p>
<ol start="8" style="list-style-type: decimal">
<li>Overlapping Input/Output</li>
</ol>
<p>我们可以用MVar来进行线程间同步:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">main <span class="fu">=</span> <span class="kw">do</span>
  m1 <span class="ot">&lt;-</span> newEmptyMVar
  m2 <span class="ot">&lt;-</span> newEmptyMVar

  forkIO <span class="fu">$</span> <span class="kw">do</span>
    r <span class="ot">&lt;-</span> getURL <span class="st">&quot;http://www.google.com&quot;</span>
    putMVar m1 r

  forkIO <span class="fu">$</span> <span class="kw">do</span>
    r <span class="ot">&lt;-</span> getURL <span class="st">&quot;http://zhenchao.li&quot;</span>
    putMVar m2 r

  r1 <span class="ot">&lt;-</span> takeMVar m1
  r2 <span class="ot">&lt;-</span> takeMVar m2
  print (B.length r1, B.length r2)</code></pre></div>
<p>对其进行抽象, 我们需要异步执行一个计算, 并且得到计算的结果:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">Async</span> a <span class="fu">=</span> <span class="dt">Async</span> (<span class="dt">MVar</span> a)

<span class="ot">async ::</span> <span class="dt">IO</span> a <span class="ot">-&gt;</span> <span class="dt">IO</span> (<span class="dt">Async</span> a)
async action <span class="fu">=</span> <span class="kw">do</span>
  var <span class="ot">&lt;-</span> newEmptyMVar
  forkIO (<span class="kw">do</span> r <span class="ot">&lt;-</span> action; putMVar var r)
  return (<span class="dt">Async</span> var)

<span class="ot">wait ::</span> <span class="dt">Async</span> a <span class="ot">-&gt;</span> <span class="dt">IO</span> a
wait (<span class="dt">Async</span> var) <span class="fu">=</span> readMVar var</code></pre></div>
<p>要注意, 这里使用readMVar的原因是使得多个线程wait一个结果成为可能.</p>
<p>这样我们的程序就简化为:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">main <span class="fu">=</span> <span class="kw">do</span>
  a1 <span class="ot">&lt;-</span> async (getURL <span class="st">&quot;http://www.google.com&quot;</span>)
  a2 <span class="ot">&lt;-</span> async (getURL <span class="st">&quot;http://zhenchao.li&quot;</span>)
  r1 <span class="ot">&lt;-</span> wait a1
  r2 <span class="ot">&lt;-</span> wait a2
  print (B.length r1, B.length r2)</code></pre></div>
<p>Exceptions in Haskell</p>
<p>GHC对纯函数抛出的异常进行了一些拓展. 但是总的来说Haskell异常处理还不是十分一致的.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">throw ::</span> <span class="dt">Exception</span> e <span class="ot">=&gt;</span> e <span class="ot">-&gt;</span> a</code></pre></div>
<p>Exception这个typeclass的定义:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">class</span> (<span class="dt">Typeable</span> e, <span class="dt">Show</span> e) <span class="ot">=&gt;</span> <span class="dt">Exception</span> e <span class="kw">where</span></code></pre></div>
<p>Typeable是:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">class</span> <span class="dt">Typeable</span> a <span class="kw">where</span>
<span class="ot">  typeOf ::</span> a <span class="ot">-&gt;</span> <span class="dt">TypeRep</span></code></pre></div>
<p>对于任何类型, 如果实现了Typeable的instance, 就能够得到一个TypeRep. 注意这里文档里说instance的实现需要忽略a的具体值, 以使得我们可以传undefined. (make sense啊make sense)..</p>
<p>ErrorCall是一个常用的Exception</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">newtype</span> <span class="dt">ErrorCall</span> <span class="fu">=</span> <span class="dt">ErrorCall</span> <span class="dt">String</span>
  <span class="kw">deriving</span> (<span class="dt">Typeable</span>)

throw (<span class="dt">ErrorCall</span> <span class="st">&quot;oops!&quot;</span>)

<span class="co">-- 事实上, error的定义:</span>

error<span class="ot"> ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> a
error s <span class="fu">=</span> throw (<span class="dt">ErrorCall</span> s)</code></pre></div>
<p>除此之外还有IOException.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">catch<span class="ot"> ::</span> <span class="dt">Exception</span> e <span class="ot">=&gt;</span> <span class="dt">IO</span> a <span class="ot">-&gt;</span> (e <span class="ot">-&gt;</span> <span class="dt">IO</span> a) <span class="ot">-&gt;</span> <span class="dt">IO</span> a</code></pre></div>
<p>这里catch只捕获固定类型的Exception, 但是Exception是有层次关系的, 最顶层的是SomeException</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">throw (<span class="dt">ErrorCall</span> <span class="st">&quot;oops&quot;</span>) <span class="ot">`catch`</span> \e <span class="ot">-&gt;</span> print (<span class="ot">e ::</span> <span class="dt">SomeException</span>)</code></pre></div>
<p>这里需要说明, 捕获所有异常只有在调试, 以及做清理工作然后重新抛出异常这两种情况下是提倡做的, 不要吞掉异常.</p>
<p>另外常用的异常处理API:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">try ::</span> <span class="dt">Exception</span> e <span class="ot">=&gt;</span> <span class="dt">IO</span> a <span class="ot">-&gt;</span> <span class="dt">IO</span> (<span class="dt">Either</span> e a)

<span class="ot">handle ::</span> <span class="dt">Exception</span> e <span class="ot">=&gt;</span> (e <span class="ot">-&gt;</span> <span class="dt">IO</span> a) <span class="ot">-&gt;</span> <span class="dt">IO</span> a <span class="ot">-&gt;</span> <span class="dt">IO</span> a

<span class="ot">onException ::</span> <span class="dt">IO</span> a <span class="ot">-&gt;</span> <span class="dt">IO</span> b <span class="ot">-&gt;</span> <span class="dt">IO</span> a

<span class="co">-- 资源清理, 重新抛出异常</span>
onException io what <span class="fu">=</span>
 io <span class="ot">`catch`</span> \e <span class="ot">-&gt;</span> <span class="kw">do</span> _ <span class="ot">&lt;-</span> what
                     throwIO (<span class="ot">e ::</span> <span class="dt">SomeException</span>)

<span class="ot">throwIO ::</span> <span class="dt">Exception</span> e <span class="ot">=&gt;</span> e <span class="ot">-&gt;</span> <span class="dt">IO</span> a</code></pre></div>
<p>在IO monad中, throwIO保证相对其他IO的顺序, 而throw则没有这个保证.</p>
<p>最后还有两个有用的API:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">bracket ::</span> <span class="dt">IO</span> a <span class="ot">-&gt;</span> (a <span class="ot">-&gt;</span> <span class="dt">IO</span> b) <span class="ot">-&gt;</span> (a <span class="ot">-&gt;</span> <span class="dt">IO</span> c) <span class="ot">-&gt;</span> <span class="dt">IO</span> c
bracket before after during <span class="fu">=</span> <span class="kw">do</span>
  a <span class="ot">&lt;-</span> before
  c <span class="ot">&lt;-</span> during a <span class="ot">`onException`</span> after a <span class="co">-- 如果发生异常, 资源清理, 然后重新抛出</span>
  after a
  return c

<span class="ot">finally ::</span> <span class="dt">IO</span> a <span class="ot">-&gt;</span> <span class="dt">IO</span> b <span class="ot">-&gt;</span> <span class="dt">IO</span> a
finally io after <span class="fu">=</span> <span class="kw">do</span>
  io <span class="ot">`onException`</span> after
  after</code></pre></div>
<p>每一个forkIO都有一个默认异常处理handler, 它会输出这个异常然后退出线程. 如果我们希望能够在Async API当中得到另外一个线程的计算结果, 并且知道是否发生了异常, 我们需要进行修改:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">Async</span> a <span class="fu">=</span> <span class="dt">Async</span> (<span class="dt">MVar</span> (<span class="dt">Either</span> <span class="dt">SomeException</span> a))

<span class="ot">async ::</span> <span class="dt">IO</span> a <span class="ot">-&gt;</span> <span class="dt">IO</span> (<span class="dt">Async</span> a)
async action <span class="fu">=</span> <span class="kw">do</span>
  var <span class="ot">&lt;-</span> newEmptyMVar
  forkIO (<span class="kw">do</span> r <span class="ot">&lt;-</span> try action; putMVar var r)
  return (<span class="dt">Async</span> var)

<span class="ot">waitCatch ::</span> <span class="dt">Async</span> a <span class="ot">-&gt;</span> <span class="dt">IO</span> (<span class="dt">Either</span> <span class="dt">SomeException</span> a)
waitCatch (<span class="dt">Async</span> var) <span class="fu">=</span> readMVar var

<span class="ot">wait ::</span> <span class="dt">Async</span> a <span class="ot">-&gt;</span> <span class="dt">IO</span> a
wait a <span class="fu">=</span> <span class="kw">do</span>
  r <span class="ot">&lt;-</span> waitCatch a
  <span class="kw">case</span> r <span class="kw">of</span>
    <span class="dt">Left</span> e <span class="ot">-&gt;</span> throwIO e
    right a <span class="ot">-&gt;</span> return a</code></pre></div>
<p>等待最早的一个线程返回:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">waitAny ::</span> [<span class="dt">Async</span> a] <span class="ot">-&gt;</span> <span class="dt">IO</span> a
waitAny as <span class="fu">=</span> <span class="kw">do</span>
  m <span class="ot">&lt;-</span> newEmptyMVar
  <span class="kw">let</span> forkwait a <span class="fu">=</span> forkIO <span class="fu">$</span> <span class="kw">do</span> r <span class="ot">&lt;-</span> try (wait a); putMVar m r
  mapM_ forwait as
  <span class="co">-- race condition?</span>
  <span class="co">-- readMVar is not atomic, could end up taking MVar and blocked at putting it back</span>
  wait (<span class="dt">Async</span> m)

<span class="ot">main ::</span> <span class="dt">IO</span> ()
main <span class="fu">=</span> <span class="kw">do</span>
  <span class="kw">let</span>
    download url <span class="fu">=</span> <span class="kw">do</span>
      r <span class="ot">&lt;-</span> getURL url
      return (url, r)

  as <span class="ot">&lt;-</span> mapM (async <span class="fu">.</span> download) sites

  (url, r) <span class="ot">&lt;-</span> waitAny as
  printf <span class="st">&quot;%s was first (%d bytes)\n&quot;</span> url (B.length r)
  mapM_ wait as</code></pre></div>
<p>值得注意的是, 这里的waitAny是可能发生死锁的, 原因是readMVar并不是原子操作. 这个结论在irc #haskell上得到了验证, 而且这里还有ticket要去实现原子的readMVar:</p>
<p><a href="https://ghc.haskell.org/trac/ghc/ticket/4001">Implement an atomic readMVar</a></p>
<ol start="9" style="list-style-type: decimal">
<li>Cancellation and Timeouts</li>
</ol>
<p>在考虑如何中断一个线程时, 需要解决的问题是应该让被中断的线程不断轮询还是被直接终止. 轮询不是一个好方法, 而直接终止意味着我们必须对一些状态进行保护. Haskell的好处是多数计算是纯的, 对于不纯的计算我们额外进行保护就可以.</p>
<p>Asynchronous Exception</p>
<p>一个例子是, 使用bracket进行资源获取 - 资源使用 - 资源释放这个模式. 这里bracket捕获的打开文件异常以及从其他线程的Cancellation导致的异常是不同的. 前者是Synchronous Exception, 使用throw, throwIO抛出. 后者是Asynchronous Exception, 使用throwTo.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">throwTo ::</span> <span class="dt">Exception</span> e <span class="ot">=&gt;</span> <span class="dt">ThreadId</span> <span class="ot">-&gt;</span> e <span class="ot">-&gt;</span> <span class="dt">IO</span> ()</code></pre></div>
<p>这里ThreadId代表的线程可能处于running, blocked, finished之一的状态. 如果是finished, 则throwTo什么也不做.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">Async</span> a <span class="fu">=</span> <span class="dt">Async</span> <span class="dt">ThreadId</span> (<span class="dt">MVar</span> (<span class="dt">Either</span> <span class="dt">SomeException</span> a))

<span class="ot">cancel ::</span> <span class="dt">Async</span> a <span class="ot">-&gt;</span> <span class="dt">IO</span> ()
cancel (<span class="dt">Async</span> t var) <span class="fu">=</span> throwTo t <span class="dt">ThreadKilled</span>

<span class="ot">async ::</span> <span class="dt">IO</span> a <span class="ot">-&gt;</span> <span class="dt">IO</span> (<span class="dt">Async</span> a)
async action <span class="fu">=</span> <span class="kw">do</span>
  m <span class="ot">&lt;-</span> newEmptyMVar
  t <span class="ot">&lt;-</span> forkIO (<span class="kw">do</span> r <span class="ot">&lt;-</span> try action; putMVar m r)
  return (<span class="dt">Async</span> t m)

main <span class="fu">=</span> <span class="kw">do</span>
  as <span class="ot">&lt;-</span> mapM (async <span class="fu">.</span> timeDownload) sites
  
  forkIO <span class="fu">$</span> <span class="kw">do</span>
    hSetBuffering stdin <span class="dt">NoBuffering</span>
    forever <span class="fu">$</span> <span class="kw">do</span>
      c <span class="ot">&lt;-</span> getChar
      when (c <span class="fu">==</span> <span class="ch">'q'</span>) <span class="fu">$</span> mapM_ cancel as
  
  rs <span class="ot">&lt;-</span> mapM waitCatch as
  printf <span class="st">&quot;%d/%d succeeded\n&quot;</span> (length (rights rs)) (length rs)</code></pre></div>
<p>这里cancel的是一个线程, 但是在forkIO里面, 如果这个ThreadKilled的异常在try action里面发生, 则m这个MVar会被putMVar, 但是如果异常在putMVar m r之前发生, 又在try之后发生, 则会发生死锁, 这个问题书中进行了详细讨论:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">problem ::</span> <span class="dt">MVar</span> a <span class="ot">-&gt;</span> (a <span class="ot">-&gt;</span> <span class="dt">IO</span> a) <span class="ot">-&gt;</span> <span class="dt">IO</span> ()
problem m f <span class="fu">=</span> <span class="kw">do</span>
  a <span class="ot">&lt;-</span> takeMVar m
  r <span class="fu">&lt;</span> f a <span class="ot">`catch`</span> \e <span class="ot">-&gt;</span> <span class="kw">do</span> putMVar m a; throw e
  putMVar m r</code></pre></div>
<p>这里在takeMVar之后, putMVar之前, 都有可能发生asynchronous exception, 这个exception不会被当中的那个catch捕获.</p>
<p>Haskell提供了这样一个API:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">mask ::</span> ((<span class="dt">IO</span> a <span class="ot">-&gt;</span> <span class="dt">IO</span> a) <span class="ot">-&gt;</span> <span class="dt">IO</span> b) <span class="ot">-&gt;</span> <span class="dt">IO</span> b</code></pre></div>
<p>这样上面的代码就可以写成: <sub>~</sub> {.haskell} problem :: MVar a -&gt; (a -&gt; IO a) -&gt; IO () problem m f = mask $ -&gt; do a &lt;- takeMVar m r &lt;- restore (f a) <code>catch</code> -&gt; do putMVar m a; throw e putMVar m r <sub>~</sub></p>
<p>mask类型比较复杂. 我们是要把我们的一个IO b变成一个带额外参数(类型为(IO a -&gt; IO a)的函数)的IO b. 这样我们就可以在原来的IO b中, 调用这个额外参数来把我们不需要屏蔽asynchronous exception的IO恢复到没有屏蔽的状态.</p>
<p>注意Haskell(GHC)的实现里, takeMVar, putMVar都是可以被打断的(这里有比较复杂的细节).</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">uninterruptibleMask ::</span> ((<span class="dt">IO</span> a <span class="ot">-&gt;</span> <span class="dt">IO</span> a) <span class="ot">-&gt;</span> <span class="dt">IO</span> b) <span class="ot">-&gt;</span> <span class="dt">IO</span> b

<span class="ot">getMaskingState ::</span> <span class="dt">IO</span> <span class="dt">MaskingState</span>

<span class="kw">data</span> <span class="dt">MaskingState</span>
  <span class="fu">=</span> <span class="dt">Unmasked</span>
  <span class="fu">|</span> <span class="dt">MaskedInterruptible</span>
  <span class="fu">|</span> <span class="dt">MaskedUninterruptible</span></code></pre></div>
<p>我们对MVar的操作进行一下抽象, 有如下的API:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">modifyMVar_ ::</span> <span class="dt">MVar</span> a <span class="ot">-&gt;</span> (a <span class="ot">-&gt;</span> <span class="dt">IO</span> a) <span class="ot">-&gt;</span> <span class="dt">IO</span> ()
modifyMVar_ m io <span class="fu">=</span>
  mask <span class="fu">$</span> \restore <span class="ot">-&gt;</span> <span class="kw">do</span>
    a <span class="ot">&lt;-</span> takeMVar m
    a' <span class="ot">&lt;-</span> restore (io a) <span class="ot">`onException`</span> putMVar m a
    putMVar m a'

<span class="ot">modifyMVar ::</span> <span class="dt">MVar</span> a <span class="ot">-&gt;</span> (a <span class="ot">-&gt;</span> <span class="dt">IO</span> (a,b)) <span class="ot">-&gt;</span> <span class="dt">IO</span> b
modifyMVar m io <span class="fu">=</span>
  mask <span class="fu">$</span> \restore <span class="ot">-&gt;</span> <span class="kw">do</span>
    a <span class="ot">&lt;-</span> takeMVar m
    (a',b) <span class="ot">&lt;-</span> restore (io a) <span class="ot">`onException`</span> putMVar m a
    putMVar m a'
    return b
                  
<span class="ot">casMVar ::</span> <span class="dt">Eq</span> a <span class="ot">=&gt;</span> <span class="dt">MVar</span> a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">IO</span> <span class="dt">Bool</span>
casMVar m old new <span class="fu">=</span>
  modifyMVar m <span class="fu">$</span> \cur
    <span class="kw">if</span> cur <span class="fu">==</span> old
      <span class="kw">then</span> return (new, <span class="dt">True</span>)
      <span class="kw">else</span> return (cur, <span class="dt">False</span>)</code></pre></div>
<p>我们之前提到的bracket函数, 也应该有asynchronous exception的保护:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">bracket ::</span> <span class="dt">IO</span> a <span class="ot">-&gt;</span> (a <span class="ot">-&gt;</span> <span class="dt">IO</span> b) <span class="ot">-&gt;</span> (a <span class="ot">-&gt;</span> <span class="dt">IO</span> c) <span class="ot">-&gt;</span> <span class="dt">IO</span> c
bracket before after thing <span class="fu">=</span>
  mask <span class="fu">$</span> \restore <span class="ot">-&gt;</span> <span class="kw">do</span>
    a <span class="ot">&lt;-</span> before
    r <span class="ot">&lt;-</span> restore (thing a) <span class="ot">`onException`</span> after a
    _ <span class="ot">&lt;-</span> after a
    return r</code></pre></div>
<p>回顾我们之前定义的readChan</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">readChan ::</span> <span class="dt">Chan</span> a <span class="ot">-&gt;</span> <span class="dt">IO</span> a
readChan (<span class="dt">Chan</span> readVar _) <span class="fu">=</span> <span class="kw">do</span>
  stream <span class="ot">&lt;-</span> takeMVar readVar
  <span class="dt">Item</span> val new <span class="ot">&lt;-</span> readMVar stream
  putMVar readVar new
  return val</code></pre></div>
<p>第一个takeMVar之后如果发生了异步异常, 则readVar就会永远是空, 造成死锁, 可以用modifyMVar:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">readChan ::</span> <span class="dt">Chan</span> a <span class="ot">-&gt;</span> <span class="dt">IO</span> a
readChan (<span class="dt">Chan</span> readVar _) <span class="fu">=</span> <span class="kw">do</span>
  modifyMVar readVar <span class="fu">$</span> \stream <span class="ot">-&gt;</span> <span class="kw">do</span>
    <span class="dt">Item</span> val tail <span class="ot">&lt;-</span> readMVar stream
    return (tail, val)</code></pre></div>
<p>还有个问题, 就是readMVar其实也不是异步异常安全的:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">readMVar ::</span> <span class="dt">MVar</span> a <span class="ot">-&gt;</span> <span class="dt">IO</span> a
readMVar m <span class="fu">=</span> <span class="kw">do</span>
  a <span class="ot">&lt;-</span> takeMVar m
  putMVar m a
  return a</code></pre></div>
<p>我们仍然可以用modifyMVar, 也可以用withMVar:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">withMVar ::</span> <span class="dt">MVar</span> a <span class="ot">-&gt;</span> (a <span class="ot">-&gt;</span> <span class="dt">IO</span> b) <span class="ot">-&gt;</span> <span class="dt">IO</span> b</code></pre></div>
<p>而Control.Concurrent.MVar是这么定义的:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">readMVar ::</span> <span class="dt">MVar</span> a <span class="ot">-&gt;</span> <span class="dt">IO</span> a
readMVar m <span class="fu">=</span>
  mask_ <span class="fu">$</span> <span class="kw">do</span>
    a <span class="ot">&lt;-</span> takeMVar m
    putMVar m a
    return a</code></pre></div>
<p>我们之前顶一个的writeChan的异步异常安全的实现是:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">writeChan ::</span> <span class="dt">Chan</span> a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">IO</span> ()
writeChan (<span class="dt">Chan</span> _ writeVar) val <span class="fu">=</span> <span class="kw">do</span>
  newHole <span class="ot">&lt;-</span> newEmptyMVar
  mask_ <span class="fu">$</span> <span class="kw">do</span>
    oldHole <span class="ot">&lt;-</span> takeMVar writeVar
    putMVar oldHole (<span class="dt">Item</span> val newHole)
    putMVar writeVar newHole</code></pre></div>
<p>超时: 我们希望能够让一个IO运算在一定时间内完成:</p>
<p>如果IO a在一定时间内没有完成, 那么我们会给他抛出一个Timeout u的异步异常, 并且timeout返回Nothing. timeout的实现是forkIO出另外一个线程, 这个线程在一定时间之后, 会向自己抛异步异常. 但是如果本线程在超时之前完成, 则会抛出异步异常给这个创建出来的线程以结束它. 我们不能在另外一个线程里执行IO a的原因是: 1. IO a可能调用myThreadId, 而这个调用应该期望返回调用timeout的线程的id. 2. 如果调用timeout的线程被异步线程中断, 这个IO a也应该被中断.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">timeout ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> a <span class="ot">-&gt;</span> <span class="dt">IO</span> (<span class="dt">Maybe</span> a)
timeout t m
  <span class="fu">|</span> t <span class="fu">&lt;</span> <span class="dv">0</span> <span class="fu">=</span> fmap <span class="dt">Just</span> m
  <span class="fu">|</span> t <span class="fu">==</span> <span class="dv">0</span> <span class="fu">=</span> return <span class="dt">Nothing</span>
  <span class="fu">|</span> otherwise <span class="fu">=</span> <span class="kw">do</span>
    pid <span class="ot">&lt;-</span> myThreadId
    u <span class="ot">&lt;-</span> newUnique
    <span class="kw">let</span> ex <span class="fu">=</span> <span class="dt">Timeout</span> u
    handleJust
      (\e <span class="ot">-&gt;</span> <span class="kw">if</span> e <span class="fu">==</span> ex <span class="kw">then</span> <span class="dt">Just</span> () <span class="kw">else</span> <span class="dt">Nothing</span>)
      (\_ <span class="ot">-&gt;</span> return <span class="dt">Nothing</span>)
      (bracket (forkIO <span class="fu">$</span> <span class="kw">do</span> threadDelay t
                            throwTo pid ex)
               (\tid <span class="ot">-&gt;</span> throwTo tid <span class="dt">ThreadKilled</span>)
               (\_ <span class="ot">-&gt;</span> fmap <span class="dt">Just</span> m))

<span class="ot">handleJust ::</span> <span class="dt">Exception</span> e <span class="ot">=&gt;</span> (e <span class="ot">-&gt;</span> <span class="dt">Maybe</span> b) <span class="ot">-&gt;</span> (b <span class="ot">-&gt;</span> <span class="dt">IO</span> a) <span class="ot">-&gt;</span> <span class="dt">IO</span> a <span class="ot">-&gt;</span> <span class="dt">IO</span> a</code></pre></div>
<p>handleJust只会处理Timeout u这个exception, 其他情况(Nothing)会重新抛出异常. 而如果是Timeout异常, 在下面return Nothing.</p>
<p>里面的IO a比较复杂, 用到了bracket保证forkIO出来的线程一定会被回收掉. 而这个线程做的事情就是等待t, 然后向原来的线程抛出Timeout. 这里要不就是原来的线程在t时间内结束, 然后给子线程抛出ThreadKilled, 要不就是超时后, 子线程抛出Timeout异步异常.</p>
<p>当然还有感觉会是race的情况: 如果两个线程同时给对方抛出异步异常会发生什么? 答案在于, throwTo是同步的, 也就是异常在目标线程上触发以后才会返回, 这样就不会发生一个线程已经给另外一个线程抛出异常, 然后自己又接收到这个线程抛过来的异常. 而且, throwTo在目标线程mask的时候会block, 而这个过程中又恰巧能够被异步异常打断. 这个就能保证, 无论如何, 只有一个线程能够成功把异步异常抛给对方.</p>
<p>如果在异常handler里面接受到异步异常怎么办? 我们可以把异常处理放在mask里面.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">mask <span class="fu">$</span> \restore <span class="ot">-&gt;</span>
  restore action <span class="ot">`catch`</span> handler</code></pre></div>
<p>为了处理异步异常, 之前的Async函数也要重新写过:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">async ::</span> <span class="dt">IO</span> a <span class="ot">-&gt;</span> <span class="dt">IO</span> (<span class="dt">Async</span> a)
async action <span class="fu">=</span> <span class="kw">do</span>
  m <span class="ot">&lt;-</span> newEmptyMVar
  t <span class="ot">&lt;-</span> mask <span class="fu">$</span> \restore <span class="ot">-&gt;</span>
    forkIO (<span class="kw">do</span> r <span class="ot">&lt;-</span> try (restore action); putMVar m r)
  return (<span class="dt">Async</span> t m)</code></pre></div>
<p>这里, forkIO出来的线程会继承父线程的mask状态, 也就是它刚刚被创建就是异步异常被mask状态. 这是把mask放到子线程做不到的.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">forkFinally ::</span> <span class="dt">IO</span> a <span class="ot">-&gt;</span> (<span class="dt">Either</span> <span class="dt">SomeException</span> a <span class="ot">-&gt;</span> <span class="dt">IO</span> ()) <span class="ot">-&gt;</span> <span class="dt">IO</span> <span class="dt">ThreadId</span>
forkFinally action fun <span class="fu">=</span>
  mask <span class="fu">$</span> \restore <span class="ot">-&gt;</span>
    forkIO (<span class="kw">do</span> r <span class="ot">&lt;-</span> try (restore action); fun r)

<span class="ot">async ::</span> <span class="dt">IO</span> a <span class="ot">-&gt;</span> <span class="dt">IO</span> (<span class="dt">Async</span> a)
async action <span class="fu">=</span> <span class="kw">do</span>
  m <span class="ot">&lt;-</span> newEmptyMVar
  t <span class="ot">&lt;-</span> forkFinally action (putMVar m)
  return (<span class="dt">Async</span> t m)</code></pre></div>
  </section>
    <p class="meta text-right"><time class="timeago" datetime="2013-10-06" pubdate>2013-10-06</time></p>

  <section id="comment">

    <div id="disqus_thread"></div>
    <script type="text/javascript">
      /* * * CONFIGURATION VARIABLES: EDIT BEFORE PASTING INTO YOUR WEBPAGE * * */
      var disqus_shortname = 'fantasticsidtheblog'; // required: replace example with your forum shortname

      /* * * DON'T EDIT BELOW THIS LINE * * */
      (function() {
      var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
      dsq.src = 'http://' + disqus_shortname + '.disqus.com/embed.js';
      (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
      })();
    </script>
    <noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
    <a href="http://disqus.com" class="dsq-brlink">blog comments powered by <span class="logo-disqus">Disqus</span></a>
  </section>
</article>
  </div>
    </div>
  </div>

      </div>

    </div>
        <script type="text/javascript" src="../javascripts/jquery-2.1.4.min.js"></script>
        <script type="text/javascript" src="../javascripts/bootstrap.min.js"></script>
  </body>
</html>
