<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
    
    <head>
        <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
<!-- Microsoft Internet Explorer documentMode compatMode setting IE Modus --> 
<script type="text/javascript">
var IE = null;
if (window.navigator.appName == "Microsoft Internet Explorer") {
  if (document.documentMode) {
  
    IE = document.documentMode; 
    } else {
   
        IE = 5; 
          if (document.compatMode) {
      if (document.compatMode == "CSS1Compat")
      IE = 11; 
      }
    }
  }
</script>

    <meta charset="utf-8">
    <!-- X-UA --> 
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta http-equiv="X-UA-Compatible" content="IE=11" />


    <meta name="google" content="notranslate" />
    <!-- Viewport --> 
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <!-- index ROBOTS follow --> 
    <meta name="robots" content="index, follow" />
    <!-- Site Desciption --> 
    <meta name="description" content fantastic!" - 第九任博士">
        <!-- Site Desciption --> 
    <meta name="keywords" content="Hacker, Back End Engineer, Web Developer, Front End Engineer">
    <!-- Favicon --> 
    <link rel="shortcut icon" href="../static/img/ico.png" type="image/x-icon" />
    <!-- Blog Title -->
    <title>The blog</title>

    <!--     <title>{% if page.title %}{{ page.title }} - {{ site.title }}{% else %}{{ site.title }}{% endif %}</title>
--> 
    <!-- Property Metas --> 
    <meta property="og:image" content="/static/img/ix.png" />
    <meta property="og:title" content fantastic!" - 第九任博士" />
    <meta property="og:site_name" content fantastic!" - 第九任博士" />
    <!-- Canonical -->
    <link rel="canonical" href="{{ page.url | replace:'index.html','' | prepend: site.baseurl | prepend: site.url }}">
    <!-- StyleSheet -->
    <link rel="stylesheet" href="../static/css/bootstrap.min.css">
    <link rel="stylesheet" href="../static/css/spaceg.stylesheets.css">
    <link rel="stylesheet" href="../static/css/syntax.css">
    <!-- Fonts -->
    <link href="https://fonts.googleapis.com/css?family=Merriweather:400,300,300italic,400italic,700,700italic,900,900italic" rel="stylesheet" type="text/css">
    <link href="https://maxcdn.bootstrapcdn.com/font-awesome/4.2.0/css/font-awesome.min.css" rel="stylesheet" type="text/css">
    <link href="https://fonts.googleapis.com/css?family=Lora:400,700,400italic,700italic" rel="stylesheet" type="text/css">
    <link href="https://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800" rel="stylesheet" type="text/css">
    <link href="https://fonts.googleapis.com/css?family=Playfair+Display:400,700,900,400italic,700italic,900italic" rel="stylesheet" type="text/css">
    <!-- HTML5 Shim and Respond.js IE8 support of HTML5 elements and media queries -->
    <!-- WARNING: Respond.js doesn't work if you view the page via file:// -->
    <!--[if lt IE 9]>
        <script src="https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
        <script src="https://oss.maxcdn.com/libs/respond.js/1.4.2/respond.min.js"></script>
    <![endif]-->
    <style>
	#preloader {position:fixed;top:0;left:0;right:0;bottom:0;background-color:#fff; /* change if the mask should have another color then white */z-index:99; /* makes sure it stays on top */}
	#status {width:200px;height:200px;position:absolute;left:50%; /* centers the loading animation horizontally one the screen */top:50%; /* centers the loading animation vertically one the screen */background-image:url("/static/img/preloader.gif"); /* path to your loading animation */background-repeat:no-repeat;background-position:center;margin:-100px 0 0 -100px; /* is width and height divided by two */}
	ul, ol {margin-top: 0;margin-bottom: 10px;}
	.navbar-inverse {background-color: #FFF;border-color: #FFFFFF;}
</style> 
<!--link rel="stylesheet" href="/static/css/prettify.css"-->
<style>
	header.intro-header {background: #6f5499;background: no-repeat center center;background-attachment: scroll;-webkit-background-size: cover;-moz-background-size: cover;background-size: cover;-o-background-size: cover;}
	/* Preloader */#preloader {position:fixed;top:0;left:0;right:0;bottom:0;background-color:#fff; /* change if the mask should have another color then white */z-index:99; /* makes sure it stays on top */}
	#status {width:200px;height:200px;position:absolute;left:50%; /* centers the loading animation horizontally one the screen */top:50%; /* centers the loading animation vertically one the screen */background-image:; /* path to your loading animation */background-repeat:no-repeat;background-position:center;margin:-100px 0 0 -100px; /* is width and height divided by two */} 
	li {list-style: none;}
            body.modal-open 
            {overflow: hidden;padding-right: 0px;
        }
	article li {list-style: inherit;}
	article .figure {text-align: center}
    </style>
    <!-- end Loading front stylesheet here --> 
    </head>

    <body>
	<div id="preloader">
	    <div id="status">

	    </div>

	</div>  
	<!-- <\!-- Navigation -\-> -->
<!-- <nav class="navbar navbar-default navbar-custom navbar-fixed-top"> -->
<!--     <div class="container-fluid"> -->
<!--         <\!-- Brand and toggle get grouped for better mobile display -\-> -->
<!--         <div class="navbar-header page-scroll"> -->
<!--             <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#bs-example-navbar-collapse-1" aria-expanded="false"> -->
<!--                 <span class="sr-only">Toggle navigation</span> -->
<!--                 <span class="icon-bar"></span> -->
<!--                 <span class="icon-bar"></span> -->
<!--                 <span class="icon-bar"></span> -->
<!--             </button> -->
<!--             <a class="navbar-brand" href="/" id="blog-title-left-top"><i class="fa fa-terminal"></i></a> -->
<!--         </div>    -->
<!--         <\!-- Collect the nav links, forms, and other content for toggling -\-> -->
<!--         <div class="collapse navbar-collapse" id="bs-example-navbar-collapse-1"> -->
<!--             <ul class="nav navbar-nav navbar-right"> -->
<!--                 <li class="dropdown"> -->
<!--                     <a href="#portfolioModal2" data-toggle="modal"><i class="fa fa-tty" id="icon-top"></i></a> -->
<!--                 <ul class="dropdown-menu"></ul> -->
<!--                 </li> -->
<!--                 <li><a href="https://www.twitter.com/fantasticsid" id="roundbutton" target="_blank"><i class="fa fa-twitter"></i>fantasticsid</a></li> -->
<!--             </ul> -->
<!--         </div> -->
<!--         <\!-- /.navbar-collapse -\-> -->
<!--     </div> -->
<!--     <\!-- /.container -\-> -->
<!-- </nav> -->
<!-- <\!-- Portfolio Modals -\-> -->
<!--     <div class="portfolio-modal modal fade" id="portfolioModal1" tabindex="-1" role="dialog" aria-hidden="true" style="padding-right:0px; overflow: hidden;"> -->
<!--         <div class="modal-content"> -->
<!--             <div class="close-modal" data-dismiss="modal"> -->
<!--                 <div class="lr"> -->
<!--                     <div class="rl"> -->
<!--                     </div> -->
<!--                 </div> -->
<!--             </div> -->
<!--             <div class="container"> -->
<!--                 <div class="row"> -->
<!--                     <div class="col-lg-8 col-lg-offset-2"> -->
<!--                         <div class="modal-body"> -->
<!--                             <h1 class="font-style-inline-small-h1">Zhenchao Li</h1> -->
<!--                             <hr class="star-primary"> -->
<!--                             <img src="/static/img/fantasticsid.png" class="img-responsive img-centered" alt="" title=""> -->
<!--                             <p class="font-style-inline-small"> -->
<!--                               Hi! I'm Zhenchao. -->
<!--                               <br> -->
<!--                                 <a href="https://www.twitter.com/fantasticsid" target="_blank">follow me</a>. <br>  -->
<!--                                 <a href="https://www.github.com/fantasticsid" target="_blank">    <i class="fa fa-github" id="spaceg-social-modal"></i> </a>  -->
<!--                                 <a href="https://www.twitter.com/fantasticsid" target="_blank"><i class="fa fa-twitter" id="spaceg-social-modal"></i> </a>     -->
<!--                             </p> -->
<!--                             <button type="button" class="btn btn-default" data-dismiss="modal"><i class="fa fa-times"></i> Close</button> -->
<!--                         </div> -->
<!--                     </div> -->
<!--                 </div> -->
<!--             </div> -->
<!--         </div> -->
<!--     </div> -->
<!-- <\!-- Menu Modals Add New Sa.21.Feb.2015 03:22:25 -\-> -->
<!--     <div class="portfolio-modal modal fade" id="portfolioModal2" tabindex="-1" role="dialog" aria-hidden="true" style="padding-right:0px; overflow: hidden;"> -->
<!--         <div class="modal-content"> -->
<!--             <div class="close-modal" data-dismiss="modal"> -->
<!--                 <div class="lr"> -->
<!--                     <div class="rl"> -->
<!--                     </div> -->
<!--                 </div> -->
<!--             </div> -->
<!--             <div class="container"> -->
<!--                 <div class="row"> -->
<!--                     <div class="col-lg-8 col-lg-offset-2"> -->
<!--                         <div class="modal-body"> -->
<!--                             <h1 class="font-style-inline-small-h1">Zhenchao Li</h1> -->
<!--                             <hr class="star-primary"> -->
<!--                             <p class="font-style-inline-small"> -->
<!--                               Hi! I'm Zhenchao. -->
<!--                               <br> -->
<!--                         <a href="https://www.twitter.com/fantasticsid" target="_blank">follow me</a>. <br> -->
<!--                         <a href="https://www.github.com/fantasticsid" target="_blank">    <i class="fa fa-github" id="spaceg-social-modal"></i> </a>  -->
<!--                         <a href="https://www.twitter.com/fantasticsid" target="_blank"><i class="fa fa-twitter" id="spaceg-social-modal"></i> </a>     -->
<!--                     <li><a href="/">Home</a></li> -->
<!--                             </p> -->
                      
<!--                             <button type="button" class="btn btn-default" data-dismiss="modal"><i class="fa fa-times"></i> Close</button> -->
<!--                         </div> -->
<!--                     </div> -->
<!--                 </div> -->
<!--             </div> -->
<!--         </div> -->
<!--     </div> -->


        <div id="content">
            <!-- Post Header -->
<header class="intro-header">
    <div class="container">
        <div class="row">
            <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
                <div class="post-heading">
                    <h1>Parallel and Concurrent Programming in Haskell 笔记</h1>
                    
                    <span class="meta">
		    
			October  6, 2013
		    </span>
                </div>
            </div>
        </div>
    </div>
</header>

<!-- Post Content -->
<article>
    <div class="container">
        <div class="row">
            <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">

			<ol style="list-style-type: decimal">
<li>Introduction</li>
</ol>
<p>介绍了并行计算和多线程计算的概念和区别. Haskell里面并行计算是有确定执行结果的(deterministic), 并且提供了Eval Monad, Par Monad, 以及如repa和accelerate等库. 而多线程计算则有MVar, STM, actor等的支持.</p>
<ol start="2" style="list-style-type: decimal">
<li>Basic Parallelism: The Eval Monad</li>
</ol>
<p>Eval Monad. 既然是Monad, 那么从计算的角度看, 应该是应该是包含了对一个普通计算如何并行的一个Context. 所以构造Eval Monad实例的过程就可以看成是构造并行Context的过程.</p>
<p>Haskell中的表达式都是惰性求值的, 程序当中的表达式运行时的表示也是通过thunk实现的. 即使是1 + 2这样简单的表达式, 也是惰性的.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">Prelude</span><span class="fu">&gt;</span> <span class="kw">let</span> x <span class="fu">=</span> <span class="dv">1</span> <span class="fu">+</span> <span class="dv">2</span>
<span class="dt">Prelude</span><span class="fu">&gt;</span> <span class="fu">:</span>sprint x
x <span class="fu">=</span> _
<span class="dt">Prelude</span><span class="fu">&gt;</span></code></pre></div>
<p>Haskell的seq函数将一个表达式求值到WHNF (weak head normal form), 而WHNF粗略地讲, 就是一个数据结构的constructor.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">Prelude</span><span class="fu">&gt;</span> <span class="kw">let</span> swap (x, y) <span class="fu">=</span> (y, x)
<span class="dt">Prelude</span><span class="fu">&gt;</span> <span class="kw">let</span> x <span class="fu">=</span> <span class="dv">1</span> <span class="fu">+</span> <span class="dv">2</span>
<span class="dt">Prelude</span><span class="fu">&gt;</span> <span class="kw">let</span> z <span class="fu">=</span> swap(x, x <span class="fu">+</span> <span class="dv">1</span>)
<span class="dt">Prelude</span><span class="fu">&gt;</span> <span class="fu">:</span>sprint z
z <span class="fu">=</span> _
<span class="dt">Prelude</span><span class="fu">&gt;</span> seq z ()
()
<span class="dt">Prelude</span><span class="fu">&gt;</span> <span class="fu">:</span>sprint z
z <span class="fu">=</span> (_,_)
<span class="dt">Prelude</span><span class="fu">&gt;</span></code></pre></div>
<p>这里表达式z在seq之后, 被evaluate到第一个constructor, 也就是(,)</p>
<p>一个更复杂的例子, 考虑map函数:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">map<span class="ot"> ::</span> (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> [a] <span class="ot">-&gt;</span> [b]
map f [] <span class="fu">=</span> []
map f (x<span class="fu">:</span>xs) <span class="fu">=</span> f x <span class="fu">:</span> map f xs</code></pre></div>
<p>这里如果有表达式:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">Prelude</span><span class="fu">&gt;</span> <span class="kw">let</span> xs <span class="fu">=</span> map (<span class="fu">+</span> <span class="dv">1</span>) [<span class="dv">1</span><span class="fu">..</span><span class="dv">10</span>]
<span class="dt">Prelude</span><span class="fu">&gt;</span> <span class="fu">:</span>sprint xs
xs <span class="fu">=</span> _
<span class="dt">Prelude</span><span class="fu">&gt;</span> seq xs ()
()
<span class="dt">Prelude</span><span class="fu">&gt;</span> <span class="fu">:</span>sprint xs
xs <span class="fu">=</span> _ <span class="fu">:</span> _
<span class="dt">Prelude</span><span class="fu">&gt;</span></code></pre></div>
<p>这里表达式xs进行seq求值之后, 只求值到第一个constructor, 也就是(:)</p>
<p>Eval Monad</p>
<p>和State Monad等类似, Eval Monad有一些基本的combinator</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">runEval ::</span> <span class="dt">Eval</span> a <span class="ot">-&gt;</span> a

<span class="ot">rpar ::</span> a <span class="ot">-&gt;</span> <span class="dt">Eval</span> a
<span class="ot">rseq ::</span> a <span class="ot">-&gt;</span> <span class="dt">Eval</span> a</code></pre></div>
<p>关于rpar, rseq有一些管用用法, 可以精准控制是否等待表达式求值完成后返回. (rpar表示可以并行, 而rseq等待表达式完成后才返回.) 而最常用的一个用法是:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">runEval <span class="fu">$</span> <span class="kw">do</span>
  a <span class="ot">&lt;-</span> rpar (f x)
  b <span class="ot">&lt;-</span> rpar (f y)
  rseq a
  rseq b
  return (a, b)</code></pre></div>
<p>这种用法中, f x和f y并行求值, 但是整个表达式(a, b)在这两个运算完成后才返回.</p>
<p>并行数独, 这个例子演示了如何用Eval Monad并行计算若干个数独问题的解.</p>
<p>值得注意的是, 代码中:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">solutions <span class="fu">=</span> runEval <span class="fu">$</span> <span class="kw">do</span>
              as' <span class="ot">&lt;-</span> rpar (force (map solve as))
              bs' <span class="ot">&lt;-</span> rpar (force (map solve bs))
              rseq as'
              rseq bs'
              return (as' <span class="fu">++</span> bs')</code></pre></div>
<p>这里如果省略掉了force, 那么map solve as只会求值到WHNF, 也就是第一个(:)就结束了.</p>
<p>这事实上会导致返回的表达式在最终计算数独解法个数的时候:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">print (length (filter isJust solutions))</code></pre></div>
<p>才被真正的计算出来. 这样就失去了用Eval Monad进行并行化的意义了.</p>
<p>而force将一个表达式求值为NF (normal form).</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">force ::</span> <span class="dt">NFData</span> a <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> a</code></pre></div>
<p>parMap: 为了增加并行的粒度</p>
<p>它的定义十分直接:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">parMap ::</span> (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> [a] <span class="ot">-&gt;</span> <span class="dt">Eval</span> [b]
parMap f [] <span class="fu">=</span> return
parMap f (a<span class="fu">:</span>as) <span class="fu">=</span> <span class="kw">do</span>
  b <span class="ot">&lt;-</span> rpar (f a)
  bs <span class="ot">&lt;-</span> parMap f as
  return (b<span class="fu">:</span>bs)</code></pre></div>
<p>每一次使用rpar的时候, 我们都在创建spark, 这些spark在系统的一个spark池中. 而它们最终可能有多种结果:</p>
<ul>
<li>overflowed</li>
</ul>
<p>spark太多, spark pool放不下</p>
<ul>
<li>dud</li>
</ul>
<p>表达式已经被求值</p>
<ul>
<li>GC’d</li>
</ul>
<p>程序运行的时候并没有用到这个表达式</p>
<ul>
<li>fizzled</li>
</ul>
<p>表达式创建的时候并没有被求值, 但是之后程序的其余部分对其进行了求值. 这些spark也会被清理掉</p>
<p>在sudoku的例子当中, 程序开始时读入数据分割行的部分不能并行化. 这也是并行加速度不能无限制上升的原因之一. (Amdahl’s law) 另一方面, Haskell的惰性求值使得数据一旦部分读入, 就可以开始处理, 而不必等到整个列表都生成以后才开始计算.</p>
<p>Deepseq</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">force ::</span> <span class="dt">NFData</span> a <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> a</code></pre></div>
<p>force函数使得一个表达式求值为normal form.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">class</span> <span class="dt">NFData</span> a <span class="kw">where</span>
<span class="ot">  rnf ::</span> a <span class="ot">-&gt;</span> ()
  rnf a <span class="fu">=</span> a <span class="ot">`seq`</span> ()</code></pre></div>
<p>性能上, 对于一个表达式/数据结构, 求值到normal form通常要遍历整个结构, 所以复杂度是O(n)的, n是数据结构的大小. 而如果是seq, 则是常数复杂度的操作.</p>
<ol start="7" style="list-style-type: decimal">
<li>Basic Concurrency: Threads and MVars</li>
</ol>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">forkIO ::</span> <span class="dt">IO</span> () <span class="ot">-&gt;</span> <span class="dt">IO</span> <span class="dt">ThreadId</span></code></pre></div>
<p>这个API产生的是一个lightweight thread. 如果要系统线程, 则要用forkOS.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">import </span><span class="dt">Control.Concurrent</span>
<span class="kw">import </span><span class="dt">Control.Monad</span>
<span class="kw">import </span><span class="dt">System.IO</span>

main <span class="fu">=</span> <span class="kw">do</span>
  hSetBuffering stdout <span class="dt">NoBuffering</span>
  forkIO (replicateM_ <span class="dv">10</span> (putChar <span class="ch">'A'</span> <span class="fu">&gt;&gt;</span> threadDelay <span class="dv">1000000</span>))
  replicateM_ <span class="dv">10</span> (putChar <span class="ch">'B'</span> <span class="fu">&gt;&gt;</span> threadDelay <span class="dv">1000000</span>)</code></pre></div>
<p>这里使用threadDelay的原因是threaDelay是合适Haskell lightweight thread的API. 如果使用sleep, 因为GHC的内部时钟是使用操作系统的signal的, 会导致sleep的系统调用立刻返回. 而且即使禁止了RTS timer, 也必须在OS thread中调用sleep, 否则会阻塞其他的线程. threadDelay就不会有这些限制. 我的理解是, 只有和原生的库互操作时, 才可能需要用到sleep.</p>
<p>Haskell的线程默认情况下, main返回的时候就会结束. 也就是说他们默认都是daemon thread, 除了main所在的线程.</p>
<p>Haskell线程之间通讯可以用MVar</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">MVar</span> a
<span class="ot">newEmptyMVar ::</span> <span class="dt">IO</span> (<span class="dt">MVar</span> a)
<span class="ot">newMVar ::</span> a <span class="ot">-&gt;</span> <span class="dt">IO</span> (<span class="dt">MVar</span> a)
<span class="ot">takeMVar ::</span> <span class="dt">MVar</span> a <span class="ot">-&gt;</span> <span class="dt">IO</span> a
<span class="ot">putMVar ::</span> <span class="dt">MVar</span> a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">IO</span> ()</code></pre></div>
<p>这里MVar的API设计与后面的STM TVar的设计很像, 但是不能像TVar那样进行组合.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">main <span class="fu">=</span> <span class="kw">do</span>
  m <span class="ot">&lt;-</span> newEmptyMVar
  forkIO <span class="fu">$</span> putMVar m <span class="ch">'x'</span>
  r <span class="ot">&lt;-</span> takeMVar m
  print r</code></pre></div>
<p>MVar可以作为线程之间通讯的一种方法. 奇妙的是, 如果发生死锁, Haskell的runtime会检测到并且抛出异常.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">import </span><span class="dt">Control.Concurrent</span>

main <span class="fu">=</span> <span class="kw">do</span>
  m <span class="ot">&lt;-</span> newEmptyMVar
  takeMVar m</code></pre></div>
<p>所以总结下来, MVar可以看做是一个容量为1的channel, 可以用作线程间通讯, Haskell里面多个线程需要操作一个状态的时候, 可以把这个状态放在MVar里面, 这样takeMVar的时候就获得了状态并且对其加锁. putMVar的时候就更新了状态并且解锁, 当然, 也可以用MVar ()来代表一个锁.</p>
<p>MVar是Haskell里面并发数据结构的基本构件.</p>
<p>用MVar可以构建出一个logging service:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">Logger</span> <span class="fu">=</span> <span class="dt">Logger</span> (<span class="dt">MVar</span> <span class="dt">LogCommand</span>)
<span class="kw">data</span> <span class="dt">LogCommand</span> <span class="fu">=</span> <span class="dt">Message</span> <span class="dt">String</span> <span class="fu">|</span> <span class="dt">Stop</span> (<span class="dt">MVar</span> ())

<span class="ot">initLogger ::</span> <span class="dt">IO</span> <span class="dt">Logger</span>
initLogger <span class="fu">=</span> <span class="kw">do</span>
  m <span class="ot">&lt;-</span> newEmptyMVar
  <span class="kw">let</span> l <span class="fu">=</span> <span class="dt">Logger</span> m
  forkIO (logger l)
  return l

<span class="ot">logger ::</span> <span class="dt">Logger</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> ()
logger (<span class="dt">Logger</span> m) <span class="fu">=</span> loop
  <span class="kw">where</span>
    loop <span class="fu">=</span> <span class="kw">do</span>
    <span class="kw">case</span> cmd <span class="kw">of</span>
      <span class="dt">Message</span> msg <span class="ot">-&gt;</span> <span class="kw">do</span>
        putStrLn msg
        loop
      <span class="dt">Stop</span> s <span class="ot">-&gt;</span> <span class="kw">do</span>
        putStrLn <span class="st">&quot;logger: stop&quot;</span>
        putMVar s ()

<span class="ot">logMessage ::</span> <span class="dt">Logger</span> <span class="ot">-&gt;</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> ()
logMessage (<span class="dt">Logger</span> m) s <span class="fu">=</span> putMVar m (<span class="dt">Message</span> s)

<span class="ot">logStop ::</span> <span class="dt">Logger</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> ()
logStop (<span class="dt">Logger</span> m) <span class="fu">=</span> <span class="kw">do</span>
  s <span class="ot">&lt;-</span> newEmptyMVar
  putMVar m (<span class="dt">Stop</span> s)
  takeMVar s</code></pre></div>
<p>如果不用MVar, 以上的logging service用C++实现要用到Lock, Condition Variable. MVar可以作为Lock(takeMVar, putMVar), 也可以作为Condition Variable(takeMVar阻塞直到有线程putMVar).</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">type</span> <span class="dt">Name</span> <span class="fu">=</span> <span class="dt">String</span>
<span class="kw">type</span> <span class="dt">PhoneNumber</span> <span class="fu">=</span> <span class="dt">String</span>
<span class="kw">type</span> <span class="dt">PhoneBook</span> <span class="fu">=</span> <span class="dt">Map</span> <span class="dt">Name</span> <span class="dt">PhoneNumber</span>

<span class="kw">newtype</span> <span class="dt">PhoneBookState</span> <span class="fu">=</span> <span class="dt">PhoneBookState</span> (<span class="dt">MVar</span> <span class="dt">PhoneBook</span>)</code></pre></div>
<p>这里PhoneBookState可以在export的时候以抽象的形式出现.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">insert ::</span> <span class="dt">PhoneBookState</span> <span class="ot">-&gt;</span> <span class="dt">Name</span> <span class="ot">-&gt;</span> <span class="dt">Phone</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> ()
insert (<span class="dt">PhoneBookState</span> m) name number <span class="fu">=</span> <span class="kw">do</span>
  book <span class="ot">&lt;-</span> takeMVar m
  putMVar m (Map.insert name number book)

lookup<span class="ot"> ::</span> <span class="dt">PhoneBookState</span> <span class="ot">-&gt;</span> <span class="dt">Name</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> (<span class="dt">Maybe</span> <span class="dt">PhoneNumber</span>)
lookup (<span class="dt">PhoneBookState</span> m) name <span class="fu">=</span> <span class="kw">do</span>
  book <span class="ot">&lt;-</span> takeMVar m
  putMVar m book
  return (Map.lookup name book)</code></pre></div>
<p>这里注意, 我们的查找事实上是在takeMVar, putMVar之后发生. 这对于提高并发是一件好事. 当然, 这得益于Map是immutable data structure这一事实, 否则我们就必须在持有锁期间进行查找.</p>
<p>另外一点值得注意点是, putMVar m (Map.insert name number book)之后, m里面是一个thunk. 如果我们要减少space leak, 需要:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">putMVar m <span class="fu">$!</span> Map.insert name number book</code></pre></div>
<p>但是这样, Map.insert就要在putMVar之前执行完. 如果我们既要减少space leak, 又要使得持有锁的时间尽量短, 可以这样做:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">let</span> book' <span class="fu">=</span> Map.insert name number book
putMVar m book'
seq book' (return ())</code></pre></div>
<p>这里我感觉, 在极端情况下, putMVar之后, 在seq之前, 如果有其他线程获得这个MVar, 那么一致性就要依靠下面的thunk如何保持一致性了.</p>
<p>Unbounded Channels</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">Chan</span> a

<span class="ot">newChan ::</span> <span class="dt">IO</span> (<span class="dt">Chan</span> a)
<span class="ot">readChan ::</span> <span class="dt">Chan</span> a <span class="ot">-&gt;</span> <span class="dt">IO</span> a
<span class="ot">writeChan ::</span> <span class="dt">Chan</span> a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">IO</span> ()</code></pre></div>
<p>这里再次注意这个API和MVar, TVar的API之间的相似性.</p>
<p>Channel有相对复杂的结构:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">type</span> <span class="dt">Stream</span> a <span class="fu">=</span> <span class="dt">MVar</span> (<span class="dt">Item</span> a)
<span class="kw">data</span> <span class="dt">Item</span> a <span class="fu">=</span> <span class="dt">Item</span> a (<span class="dt">Stream</span> a)

<span class="kw">data</span> <span class="dt">Chan</span> a <span class="fu">=</span> <span class="dt">Chan</span> (<span class="dt">MVar</span> (<span class="dt">Stream</span> a)) (<span class="dt">MVar</span> (<span class="dt">Stream</span> a))</code></pre></div>
<p>Chan有两个MVar包含有两个Stream, 分别用作read pointer和write pointer.</p>
<p>创建一个新的Channel时, 只需要创建一个新的空Stream:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">newChan ::</span> <span class="dt">IO</span> (<span class="dt">Chan</span> a)
newChan <span class="fu">=</span> <span class="kw">do</span>
  hole <span class="ot">&lt;-</span> newEmptyMVar
  readVar <span class="ot">&lt;-</span> newMVar hole
  writeVar <span class="ot">&lt;-</span> newMVar hole
  return (<span class="dt">Chan</span> readVar writeVar)</code></pre></div>
<p>加入一个新元素, 我们需要构建一个新的Item, 然后让其后继结点指向当前write pointer, 然后调整write pointer. 这里和链表头插入新元素一样, 但是要注意concurrent safety:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">writeChan ::</span> <span class="dt">Chan</span> a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">IO</span> ()
writeChan (<span class="dt">Chan</span> _ writeVar) val <span class="fu">=</span> <span class="kw">do</span>
  newHole <span class="ot">&lt;-</span> newEmptyMVar
  oldHole <span class="ot">&lt;-</span> takeMVar writeVar
  putMVar oldHole (<span class="dt">Item</span> val newHole)
  putMVar writeVar newHole</code></pre></div>
<p>而拿出一个元素的代码:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">readChan ::</span> <span class="dt">Chan</span> a <span class="ot">-&gt;</span> <span class="dt">IO</span> a
readChan (<span class="dt">Chan</span> readVar _) <span class="fu">=</span> <span class="kw">do</span>
  stream <span class="ot">&lt;-</span> takeMVar readVar
  <span class="dt">Item</span> val tail <span class="ot">&lt;-</span> takeMVar stream
  putMVar readVar tail
  return val</code></pre></div>
<p>就writeChan, readChan来说, 代码并不复杂. 但是我们写的是concurrent code, 所以要注意是否线程安全.</p>
<p>当Channel是空的时候, readChan的第二个takeMVar会block, 直到有其他线程writeChan. 这里由于是空Channel, 所以read pointer和write pointer指向的是同一个MVar. 第一个线程阻塞时, 第二个线程可以putMVar, 从而第一个线程得以继续. 这里的极端情况, 即使是writeChan刚写入空Channel的第一个元素时, readChan读出第一个元素, 也是正确的. read pointer, write pointer保证了同时只有一个read, write操作(这里其实2个操作都是read write, 而不是read only, write only), 但是read, write可以同时存在.</p>
<p>对以上实现稍加修改, 可以得到multicast channel:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">dupChan ::</span> <span class="dt">Chan</span> a <span class="ot">-&gt;</span> <span class="dt">IO</span> (<span class="dt">Chan</span> a)
dupChan (<span class="dt">Chan</span> _ writeVar) <span class="fu">=</span> <span class="kw">do</span>
  hole <span class="ot">&lt;-</span> readMVar writeVar
  newReadVar <span class="ot">&lt;-</span> newMVar hole
  return (<span class="dt">Chan</span> newReadVar writeVar)

<span class="ot">readMVar ::</span> <span class="dt">MVar</span> a <span class="ot">-&gt;</span> <span class="dt">IO</span> a
readMVar m <span class="fu">=</span> <span class="kw">do</span>
  a <span class="ot">&lt;-</span> takeMVar m
  putMVar m a
  return a</code></pre></div>
<p>也就是, 新的channel和以前的channel共用了同一个write pointer, 但是read pointer仍然是分开的. 但是, 这里的一个问题是, 我们在实现readChan的时候使用了takeMVar stream. 这样, 指向这个Item的MVar就是空的了. 所以我们应该要做如下更改:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">readChan ::</span> <span class="dt">Chan</span> a <span class="ot">-&gt;</span> <span class="dt">IO</span> a
readChan (<span class="dt">Chan</span> readVar _) <span class="fu">=</span> <span class="kw">do</span>
  stream <span class="ot">&lt;-</span> takeMVar readVar
  <span class="dt">Item</span> val tail <span class="ot">&lt;-</span> readMVar stream
  putMVar readVar tail
  return val</code></pre></div>
<p>我们还可以继续丰富channel的API:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">unGetChan ::</span> <span class="dt">Chan</span> a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">IO</span> ()
unGetChan (<span class="dt">Chan</span> readVar _) val <span class="fu">=</span> <span class="kw">do</span>
  newReadEnd <span class="ot">&lt;-</span> newEmptyMvar
  readEnd <span class="ot">&lt;-</span> takeMVar readVar
  putMVar newReadEnd (<span class="dt">Item</span> val readEnd)
  putMVar readVar newReadEnd</code></pre></div>
<p>但是这个函数与readChan, 在channel为空的时候会死锁: readChan得到了readVar, 然后阻塞在stream上. 而unGetChan阻塞在readVar上. 理想情况下, 应该是unGetChan成功返回然后readChan也返回.</p>
<p>到这里, 我们发现, 使用MVar构建跟更高层的并发数据结构时需要考虑的情况变得越来越多了.</p>
<p>GHC保证, 只要没有线程一直获取一个MVar不释放, 那么在一个MVar上等待的线程不会永远阻塞. GHC会用一个queue保存一个MVar上等待的线程, 无论是putMVar还是takeMVar. 这里书上还提到了实现里的一个注意点: 当MVar上有值之后, 仅仅唤醒一个FIFO队列的第一个线程是不够的, 因为这时可能有另外一个线程正在运行从而获得这个MVar的控制权. 正确的做法是, 原子性地唤醒第一个等待的线程并且完成这个线程阻塞的MVar操作.</p>
<p>线程公平性</p>
<p>stdout这个文件描述符是用一个MVar表示的. 所以开始时, 两个不断输出字符的线程会交替输出, 原因是这两个线程交替在FIFO队列的队末进行等待.</p>
<p>这个实现的好处是: 多个线程阻塞在同一个MVar上时, 如果有一个putMVar/takeMVar使得这些线程能够继续, 则只有一个线程被unblock. 而MVar的公平性, 以及这个单个线程唤醒的特性是使得MVar没有被STM完全取代的原因.</p>
<ol start="8" style="list-style-type: decimal">
<li>Overlapping Input/Output</li>
</ol>
<p>我们可以用MVar来进行线程间同步:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">main <span class="fu">=</span> <span class="kw">do</span>
  m1 <span class="ot">&lt;-</span> newEmptyMVar
  m2 <span class="ot">&lt;-</span> newEmptyMVar

  forkIO <span class="fu">$</span> <span class="kw">do</span>
    r <span class="ot">&lt;-</span> getURL <span class="st">&quot;http://www.google.com&quot;</span>
    putMVar m1 r

  forkIO <span class="fu">$</span> <span class="kw">do</span>
    r <span class="ot">&lt;-</span> getURL <span class="st">&quot;http://zhenchao.li&quot;</span>
    putMVar m2 r

  r1 <span class="ot">&lt;-</span> takeMVar m1
  r2 <span class="ot">&lt;-</span> takeMVar m2
  print (B.length r1, B.length r2)</code></pre></div>
<p>对其进行抽象, 我们需要异步执行一个计算, 并且得到计算的结果:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">Async</span> a <span class="fu">=</span> <span class="dt">Async</span> (<span class="dt">MVar</span> a)

<span class="ot">async ::</span> <span class="dt">IO</span> a <span class="ot">-&gt;</span> <span class="dt">IO</span> (<span class="dt">Async</span> a)
async action <span class="fu">=</span> <span class="kw">do</span>
  var <span class="ot">&lt;-</span> newEmptyMVar
  forkIO (<span class="kw">do</span> r <span class="ot">&lt;-</span> action; putMVar var r)
  return (<span class="dt">Async</span> var)

<span class="ot">wait ::</span> <span class="dt">Async</span> a <span class="ot">-&gt;</span> <span class="dt">IO</span> a
wait (<span class="dt">Async</span> var) <span class="fu">=</span> readMVar var</code></pre></div>
<p>要注意, 这里使用readMVar的原因是使得多个线程wait一个结果成为可能.</p>
<p>这样我们的程序就简化为:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">main <span class="fu">=</span> <span class="kw">do</span>
  a1 <span class="ot">&lt;-</span> async (getURL <span class="st">&quot;http://www.google.com&quot;</span>)
  a2 <span class="ot">&lt;-</span> async (getURL <span class="st">&quot;http://zhenchao.li&quot;</span>)
  r1 <span class="ot">&lt;-</span> wait a1
  r2 <span class="ot">&lt;-</span> wait a2
  print (B.length r1, B.length r2)</code></pre></div>
<p>Exceptions in Haskell</p>
<p>GHC对纯函数抛出的异常进行了一些拓展. 但是总的来说Haskell异常处理还不是十分一致的.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">throw ::</span> <span class="dt">Exception</span> e <span class="ot">=&gt;</span> e <span class="ot">-&gt;</span> a</code></pre></div>
<p>Exception这个typeclass的定义:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">class</span> (<span class="dt">Typeable</span> e, <span class="dt">Show</span> e) <span class="ot">=&gt;</span> <span class="dt">Exception</span> e <span class="kw">where</span></code></pre></div>
<p>Typeable是:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">class</span> <span class="dt">Typeable</span> a <span class="kw">where</span>
<span class="ot">  typeOf ::</span> a <span class="ot">-&gt;</span> <span class="dt">TypeRep</span></code></pre></div>
<p>对于任何类型, 如果实现了Typeable的instance, 就能够得到一个TypeRep. 注意这里文档里说instance的实现需要忽略a的具体值, 以使得我们可以传undefined. (make sense啊make sense)..</p>
<p>ErrorCall是一个常用的Exception</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">newtype</span> <span class="dt">ErrorCall</span> <span class="fu">=</span> <span class="dt">ErrorCall</span> <span class="dt">String</span>
  <span class="kw">deriving</span> (<span class="dt">Typeable</span>)

throw (<span class="dt">ErrorCall</span> <span class="st">&quot;oops!&quot;</span>)

<span class="co">-- 事实上, error的定义:</span>

error<span class="ot"> ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> a
error s <span class="fu">=</span> throw (<span class="dt">ErrorCall</span> s)</code></pre></div>
<p>除此之外还有IOException.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">catch<span class="ot"> ::</span> <span class="dt">Exception</span> e <span class="ot">=&gt;</span> <span class="dt">IO</span> a <span class="ot">-&gt;</span> (e <span class="ot">-&gt;</span> <span class="dt">IO</span> a) <span class="ot">-&gt;</span> <span class="dt">IO</span> a</code></pre></div>
<p>这里catch只捕获固定类型的Exception, 但是Exception是有层次关系的, 最顶层的是SomeException</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">throw (<span class="dt">ErrorCall</span> <span class="st">&quot;oops&quot;</span>) <span class="ot">`catch`</span> \e <span class="ot">-&gt;</span> print (<span class="ot">e ::</span> <span class="dt">SomeException</span>)</code></pre></div>
<p>这里需要说明, 捕获所有异常只有在调试, 以及做清理工作然后重新抛出异常这两种情况下是提倡做的, 不要吞掉异常.</p>
<p>另外常用的异常处理API:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">try ::</span> <span class="dt">Exception</span> e <span class="ot">=&gt;</span> <span class="dt">IO</span> a <span class="ot">-&gt;</span> <span class="dt">IO</span> (<span class="dt">Either</span> e a)

<span class="ot">handle ::</span> <span class="dt">Exception</span> e <span class="ot">=&gt;</span> (e <span class="ot">-&gt;</span> <span class="dt">IO</span> a) <span class="ot">-&gt;</span> <span class="dt">IO</span> a <span class="ot">-&gt;</span> <span class="dt">IO</span> a

<span class="ot">onException ::</span> <span class="dt">IO</span> a <span class="ot">-&gt;</span> <span class="dt">IO</span> b <span class="ot">-&gt;</span> <span class="dt">IO</span> a

<span class="co">-- 资源清理, 重新抛出异常</span>
onException io what <span class="fu">=</span>
 io <span class="ot">`catch`</span> \e <span class="ot">-&gt;</span> <span class="kw">do</span> _ <span class="ot">&lt;-</span> what
                     throwIO (<span class="ot">e ::</span> <span class="dt">SomeException</span>)

<span class="ot">throwIO ::</span> <span class="dt">Exception</span> e <span class="ot">=&gt;</span> e <span class="ot">-&gt;</span> <span class="dt">IO</span> a</code></pre></div>
<p>在IO monad中, throwIO保证相对其他IO的顺序, 而throw则没有这个保证.</p>
<p>最后还有两个有用的API:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">bracket ::</span> <span class="dt">IO</span> a <span class="ot">-&gt;</span> (a <span class="ot">-&gt;</span> <span class="dt">IO</span> b) <span class="ot">-&gt;</span> (a <span class="ot">-&gt;</span> <span class="dt">IO</span> c) <span class="ot">-&gt;</span> <span class="dt">IO</span> c
bracket before after during <span class="fu">=</span> <span class="kw">do</span>
  a <span class="ot">&lt;-</span> before
  c <span class="ot">&lt;-</span> during a <span class="ot">`onException`</span> after a <span class="co">-- 如果发生异常, 资源清理, 然后重新抛出</span>
  after a
  return c

<span class="ot">finally ::</span> <span class="dt">IO</span> a <span class="ot">-&gt;</span> <span class="dt">IO</span> b <span class="ot">-&gt;</span> <span class="dt">IO</span> a
finally io after <span class="fu">=</span> <span class="kw">do</span>
  io <span class="ot">`onException`</span> after
  after</code></pre></div>
<p>每一个forkIO都有一个默认异常处理handler, 它会输出这个异常然后退出线程. 如果我们希望能够在Async API当中得到另外一个线程的计算结果, 并且知道是否发生了异常, 我们需要进行修改:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">Async</span> a <span class="fu">=</span> <span class="dt">Async</span> (<span class="dt">MVar</span> (<span class="dt">Either</span> <span class="dt">SomeException</span> a))

<span class="ot">async ::</span> <span class="dt">IO</span> a <span class="ot">-&gt;</span> <span class="dt">IO</span> (<span class="dt">Async</span> a)
async action <span class="fu">=</span> <span class="kw">do</span>
  var <span class="ot">&lt;-</span> newEmptyMVar
  forkIO (<span class="kw">do</span> r <span class="ot">&lt;-</span> try action; putMVar var r)
  return (<span class="dt">Async</span> var)

<span class="ot">waitCatch ::</span> <span class="dt">Async</span> a <span class="ot">-&gt;</span> <span class="dt">IO</span> (<span class="dt">Either</span> <span class="dt">SomeException</span> a)
waitCatch (<span class="dt">Async</span> var) <span class="fu">=</span> readMVar var

<span class="ot">wait ::</span> <span class="dt">Async</span> a <span class="ot">-&gt;</span> <span class="dt">IO</span> a
wait a <span class="fu">=</span> <span class="kw">do</span>
  r <span class="ot">&lt;-</span> waitCatch a
  <span class="kw">case</span> r <span class="kw">of</span>
    <span class="dt">Left</span> e <span class="ot">-&gt;</span> throwIO e
    right a <span class="ot">-&gt;</span> return a</code></pre></div>
<p>等待最早的一个线程返回:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">waitAny ::</span> [<span class="dt">Async</span> a] <span class="ot">-&gt;</span> <span class="dt">IO</span> a
waitAny as <span class="fu">=</span> <span class="kw">do</span>
  m <span class="ot">&lt;-</span> newEmptyMVar
  <span class="kw">let</span> forkwait a <span class="fu">=</span> forkIO <span class="fu">$</span> <span class="kw">do</span> r <span class="ot">&lt;-</span> try (wait a); putMVar m r
  mapM_ forwait as
  <span class="co">-- race condition?</span>
  <span class="co">-- readMVar is not atomic, could end up taking MVar and blocked at putting it back</span>
  wait (<span class="dt">Async</span> m)

<span class="ot">main ::</span> <span class="dt">IO</span> ()
main <span class="fu">=</span> <span class="kw">do</span>
  <span class="kw">let</span>
    download url <span class="fu">=</span> <span class="kw">do</span>
      r <span class="ot">&lt;-</span> getURL url
      return (url, r)

  as <span class="ot">&lt;-</span> mapM (async <span class="fu">.</span> download) sites

  (url, r) <span class="ot">&lt;-</span> waitAny as
  printf <span class="st">&quot;%s was first (%d bytes)\n&quot;</span> url (B.length r)
  mapM_ wait as</code></pre></div>
<p>值得注意的是, 这里的waitAny是可能发生死锁的, 原因是readMVar并不是原子操作. 这个结论在irc #haskell上得到了验证, 而且这里还有ticket要去实现原子的readMVar:</p>
<p><a href="https://ghc.haskell.org/trac/ghc/ticket/4001">Implement an atomic readMVar</a></p>
<ol start="9" style="list-style-type: decimal">
<li>Cancellation and Timeouts</li>
</ol>
<p>在考虑如何中断一个线程时, 需要解决的问题是应该让被中断的线程不断轮询还是被直接终止. 轮询不是一个好方法, 而直接终止意味着我们必须对一些状态进行保护. Haskell的好处是多数计算是纯的, 对于不纯的计算我们额外进行保护就可以.</p>
<p>Asynchronous Exception</p>
<p>一个例子是, 使用bracket进行资源获取 - 资源使用 - 资源释放这个模式. 这里bracket捕获的打开文件异常以及从其他线程的Cancellation导致的异常是不同的. 前者是Synchronous Exception, 使用throw, throwIO抛出. 后者是Asynchronous Exception, 使用throwTo.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">throwTo ::</span> <span class="dt">Exception</span> e <span class="ot">=&gt;</span> <span class="dt">ThreadId</span> <span class="ot">-&gt;</span> e <span class="ot">-&gt;</span> <span class="dt">IO</span> ()</code></pre></div>
<p>这里ThreadId代表的线程可能处于running, blocked, finished之一的状态. 如果是finished, 则throwTo什么也不做.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">Async</span> a <span class="fu">=</span> <span class="dt">Async</span> <span class="dt">ThreadId</span> (<span class="dt">MVar</span> (<span class="dt">Either</span> <span class="dt">SomeException</span> a))

<span class="ot">cancel ::</span> <span class="dt">Async</span> a <span class="ot">-&gt;</span> <span class="dt">IO</span> ()
cancel (<span class="dt">Async</span> t var) <span class="fu">=</span> throwTo t <span class="dt">ThreadKilled</span>

<span class="ot">async ::</span> <span class="dt">IO</span> a <span class="ot">-&gt;</span> <span class="dt">IO</span> (<span class="dt">Async</span> a)
async action <span class="fu">=</span> <span class="kw">do</span>
  m <span class="ot">&lt;-</span> newEmptyMVar
  t <span class="ot">&lt;-</span> forkIO (<span class="kw">do</span> r <span class="ot">&lt;-</span> try action; putMVar m r)
  return (<span class="dt">Async</span> t m)

main <span class="fu">=</span> <span class="kw">do</span>
  as <span class="ot">&lt;-</span> mapM (async <span class="fu">.</span> timeDownload) sites
  
  forkIO <span class="fu">$</span> <span class="kw">do</span>
    hSetBuffering stdin <span class="dt">NoBuffering</span>
    forever <span class="fu">$</span> <span class="kw">do</span>
      c <span class="ot">&lt;-</span> getChar
      when (c <span class="fu">==</span> <span class="ch">'q'</span>) <span class="fu">$</span> mapM_ cancel as
  
  rs <span class="ot">&lt;-</span> mapM waitCatch as
  printf <span class="st">&quot;%d/%d succeeded\n&quot;</span> (length (rights rs)) (length rs)</code></pre></div>
<p>这里cancel的是一个线程, 但是在forkIO里面, 如果这个ThreadKilled的异常在try action里面发生, 则m这个MVar会被putMVar, 但是如果异常在putMVar m r之前发生, 又在try之后发生, 则会发生死锁, 这个问题书中进行了详细讨论:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">problem ::</span> <span class="dt">MVar</span> a <span class="ot">-&gt;</span> (a <span class="ot">-&gt;</span> <span class="dt">IO</span> a) <span class="ot">-&gt;</span> <span class="dt">IO</span> ()
problem m f <span class="fu">=</span> <span class="kw">do</span>
  a <span class="ot">&lt;-</span> takeMVar m
  r <span class="fu">&lt;</span> f a <span class="ot">`catch`</span> \e <span class="ot">-&gt;</span> <span class="kw">do</span> putMVar m a; throw e
  putMVar m r</code></pre></div>
<p>这里在takeMVar之后, putMVar之前, 都有可能发生asynchronous exception, 这个exception不会被当中的那个catch捕获.</p>
<p>Haskell提供了这样一个API:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">mask ::</span> ((<span class="dt">IO</span> a <span class="ot">-&gt;</span> <span class="dt">IO</span> a) <span class="ot">-&gt;</span> <span class="dt">IO</span> b) <span class="ot">-&gt;</span> <span class="dt">IO</span> b</code></pre></div>
<p>这样上面的代码就可以写成: <sub>~</sub> {.haskell} problem :: MVar a -&gt; (a -&gt; IO a) -&gt; IO () problem m f = mask $ -&gt; do a &lt;- takeMVar m r &lt;- restore (f a) <code>catch</code> -&gt; do putMVar m a; throw e putMVar m r <sub>~</sub></p>
<p>mask类型比较复杂. 我们是要把我们的一个IO b变成一个带额外参数(类型为(IO a -&gt; IO a)的函数)的IO b. 这样我们就可以在原来的IO b中, 调用这个额外参数来把我们不需要屏蔽asynchronous exception的IO恢复到没有屏蔽的状态.</p>
<p>注意Haskell(GHC)的实现里, takeMVar, putMVar都是可以被打断的(这里有比较复杂的细节).</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">uninterruptibleMask ::</span> ((<span class="dt">IO</span> a <span class="ot">-&gt;</span> <span class="dt">IO</span> a) <span class="ot">-&gt;</span> <span class="dt">IO</span> b) <span class="ot">-&gt;</span> <span class="dt">IO</span> b

<span class="ot">getMaskingState ::</span> <span class="dt">IO</span> <span class="dt">MaskingState</span>

<span class="kw">data</span> <span class="dt">MaskingState</span>
  <span class="fu">=</span> <span class="dt">Unmasked</span>
  <span class="fu">|</span> <span class="dt">MaskedInterruptible</span>
  <span class="fu">|</span> <span class="dt">MaskedUninterruptible</span></code></pre></div>
<p>我们对MVar的操作进行一下抽象, 有如下的API:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">modifyMVar_ ::</span> <span class="dt">MVar</span> a <span class="ot">-&gt;</span> (a <span class="ot">-&gt;</span> <span class="dt">IO</span> a) <span class="ot">-&gt;</span> <span class="dt">IO</span> ()
modifyMVar_ m io <span class="fu">=</span>
  mask <span class="fu">$</span> \restore <span class="ot">-&gt;</span> <span class="kw">do</span>
    a <span class="ot">&lt;-</span> takeMVar m
    a' <span class="ot">&lt;-</span> restore (io a) <span class="ot">`onException`</span> putMVar m a
    putMVar m a'

<span class="ot">modifyMVar ::</span> <span class="dt">MVar</span> a <span class="ot">-&gt;</span> (a <span class="ot">-&gt;</span> <span class="dt">IO</span> (a,b)) <span class="ot">-&gt;</span> <span class="dt">IO</span> b
modifyMVar m io <span class="fu">=</span>
  mask <span class="fu">$</span> \restore <span class="ot">-&gt;</span> <span class="kw">do</span>
    a <span class="ot">&lt;-</span> takeMVar m
    (a',b) <span class="ot">&lt;-</span> restore (io a) <span class="ot">`onException`</span> putMVar m a
    putMVar m a'
    return b
                  
<span class="ot">casMVar ::</span> <span class="dt">Eq</span> a <span class="ot">=&gt;</span> <span class="dt">MVar</span> a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">IO</span> <span class="dt">Bool</span>
casMVar m old new <span class="fu">=</span>
  modifyMVar m <span class="fu">$</span> \cur
    <span class="kw">if</span> cur <span class="fu">==</span> old
      <span class="kw">then</span> return (new, <span class="dt">True</span>)
      <span class="kw">else</span> return (cur, <span class="dt">False</span>)</code></pre></div>
<p>我们之前提到的bracket函数, 也应该有asynchronous exception的保护:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">bracket ::</span> <span class="dt">IO</span> a <span class="ot">-&gt;</span> (a <span class="ot">-&gt;</span> <span class="dt">IO</span> b) <span class="ot">-&gt;</span> (a <span class="ot">-&gt;</span> <span class="dt">IO</span> c) <span class="ot">-&gt;</span> <span class="dt">IO</span> c
bracket before after thing <span class="fu">=</span>
  mask <span class="fu">$</span> \restore <span class="ot">-&gt;</span> <span class="kw">do</span>
    a <span class="ot">&lt;-</span> before
    r <span class="ot">&lt;-</span> restore (thing a) <span class="ot">`onException`</span> after a
    _ <span class="ot">&lt;-</span> after a
    return r</code></pre></div>
<p>回顾我们之前定义的readChan</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">readChan ::</span> <span class="dt">Chan</span> a <span class="ot">-&gt;</span> <span class="dt">IO</span> a
readChan (<span class="dt">Chan</span> readVar _) <span class="fu">=</span> <span class="kw">do</span>
  stream <span class="ot">&lt;-</span> takeMVar readVar
  <span class="dt">Item</span> val new <span class="ot">&lt;-</span> readMVar stream
  putMVar readVar new
  return val</code></pre></div>
<p>第一个takeMVar之后如果发生了异步异常, 则readVar就会永远是空, 造成死锁, 可以用modifyMVar:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">readChan ::</span> <span class="dt">Chan</span> a <span class="ot">-&gt;</span> <span class="dt">IO</span> a
readChan (<span class="dt">Chan</span> readVar _) <span class="fu">=</span> <span class="kw">do</span>
  modifyMVar readVar <span class="fu">$</span> \stream <span class="ot">-&gt;</span> <span class="kw">do</span>
    <span class="dt">Item</span> val tail <span class="ot">&lt;-</span> readMVar stream
    return (tail, val)</code></pre></div>
<p>还有个问题, 就是readMVar其实也不是异步异常安全的:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">readMVar ::</span> <span class="dt">MVar</span> a <span class="ot">-&gt;</span> <span class="dt">IO</span> a
readMVar m <span class="fu">=</span> <span class="kw">do</span>
  a <span class="ot">&lt;-</span> takeMVar m
  putMVar m a
  return a</code></pre></div>
<p>我们仍然可以用modifyMVar, 也可以用withMVar:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">withMVar ::</span> <span class="dt">MVar</span> a <span class="ot">-&gt;</span> (a <span class="ot">-&gt;</span> <span class="dt">IO</span> b) <span class="ot">-&gt;</span> <span class="dt">IO</span> b</code></pre></div>
<p>而Control.Concurrent.MVar是这么定义的:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">readMVar ::</span> <span class="dt">MVar</span> a <span class="ot">-&gt;</span> <span class="dt">IO</span> a
readMVar m <span class="fu">=</span>
  mask_ <span class="fu">$</span> <span class="kw">do</span>
    a <span class="ot">&lt;-</span> takeMVar m
    putMVar m a
    return a</code></pre></div>
<p>我们之前顶一个的writeChan的异步异常安全的实现是:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">writeChan ::</span> <span class="dt">Chan</span> a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">IO</span> ()
writeChan (<span class="dt">Chan</span> _ writeVar) val <span class="fu">=</span> <span class="kw">do</span>
  newHole <span class="ot">&lt;-</span> newEmptyMVar
  mask_ <span class="fu">$</span> <span class="kw">do</span>
    oldHole <span class="ot">&lt;-</span> takeMVar writeVar
    putMVar oldHole (<span class="dt">Item</span> val newHole)
    putMVar writeVar newHole</code></pre></div>
<p>超时: 我们希望能够让一个IO运算在一定时间内完成:</p>
<p>如果IO a在一定时间内没有完成, 那么我们会给他抛出一个Timeout u的异步异常, 并且timeout返回Nothing. timeout的实现是forkIO出另外一个线程, 这个线程在一定时间之后, 会向自己抛异步异常. 但是如果本线程在超时之前完成, 则会抛出异步异常给这个创建出来的线程以结束它. 我们不能在另外一个线程里执行IO a的原因是: 1. IO a可能调用myThreadId, 而这个调用应该期望返回调用timeout的线程的id. 2. 如果调用timeout的线程被异步线程中断, 这个IO a也应该被中断.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">timeout ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> a <span class="ot">-&gt;</span> <span class="dt">IO</span> (<span class="dt">Maybe</span> a)
timeout t m
  <span class="fu">|</span> t <span class="fu">&lt;</span> <span class="dv">0</span> <span class="fu">=</span> fmap <span class="dt">Just</span> m
  <span class="fu">|</span> t <span class="fu">==</span> <span class="dv">0</span> <span class="fu">=</span> return <span class="dt">Nothing</span>
  <span class="fu">|</span> otherwise <span class="fu">=</span> <span class="kw">do</span>
    pid <span class="ot">&lt;-</span> myThreadId
    u <span class="ot">&lt;-</span> newUnique
    <span class="kw">let</span> ex <span class="fu">=</span> <span class="dt">Timeout</span> u
    handleJust
      (\e <span class="ot">-&gt;</span> <span class="kw">if</span> e <span class="fu">==</span> ex <span class="kw">then</span> <span class="dt">Just</span> () <span class="kw">else</span> <span class="dt">Nothing</span>)
      (\_ <span class="ot">-&gt;</span> return <span class="dt">Nothing</span>)
      (bracket (forkIO <span class="fu">$</span> <span class="kw">do</span> threadDelay t
                            throwTo pid ex)
               (\tid <span class="ot">-&gt;</span> throwTo tid <span class="dt">ThreadKilled</span>)
               (\_ <span class="ot">-&gt;</span> fmap <span class="dt">Just</span> m))

<span class="ot">handleJust ::</span> <span class="dt">Exception</span> e <span class="ot">=&gt;</span> (e <span class="ot">-&gt;</span> <span class="dt">Maybe</span> b) <span class="ot">-&gt;</span> (b <span class="ot">-&gt;</span> <span class="dt">IO</span> a) <span class="ot">-&gt;</span> <span class="dt">IO</span> a <span class="ot">-&gt;</span> <span class="dt">IO</span> a</code></pre></div>
<p>handleJust只会处理Timeout u这个exception, 其他情况(Nothing)会重新抛出异常. 而如果是Timeout异常, 在下面return Nothing.</p>
<p>里面的IO a比较复杂, 用到了bracket保证forkIO出来的线程一定会被回收掉. 而这个线程做的事情就是等待t, 然后向原来的线程抛出Timeout. 这里要不就是原来的线程在t时间内结束, 然后给子线程抛出ThreadKilled, 要不就是超时后, 子线程抛出Timeout异步异常.</p>
<p>当然还有感觉会是race的情况: 如果两个线程同时给对方抛出异步异常会发生什么? 答案在于, throwTo是同步的, 也就是异常在目标线程上触发以后才会返回, 这样就不会发生一个线程已经给另外一个线程抛出异常, 然后自己又接收到这个线程抛过来的异常. 而且, throwTo在目标线程mask的时候会block, 而这个过程中又恰巧能够被异步异常打断. 这个就能保证, 无论如何, 只有一个线程能够成功把异步异常抛给对方.</p>
<p>如果在异常handler里面接受到异步异常怎么办? 我们可以把异常处理放在mask里面.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">mask <span class="fu">$</span> \restore <span class="ot">-&gt;</span>
  restore action <span class="ot">`catch`</span> handler</code></pre></div>
<p>为了处理异步异常, 之前的Async函数也要重新写过:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">async ::</span> <span class="dt">IO</span> a <span class="ot">-&gt;</span> <span class="dt">IO</span> (<span class="dt">Async</span> a)
async action <span class="fu">=</span> <span class="kw">do</span>
  m <span class="ot">&lt;-</span> newEmptyMVar
  t <span class="ot">&lt;-</span> mask <span class="fu">$</span> \restore <span class="ot">-&gt;</span>
    forkIO (<span class="kw">do</span> r <span class="ot">&lt;-</span> try (restore action); putMVar m r)
  return (<span class="dt">Async</span> t m)</code></pre></div>
<p>这里, forkIO出来的线程会继承父线程的mask状态, 也就是它刚刚被创建就是异步异常被mask状态. 这是把mask放到子线程做不到的.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">forkFinally ::</span> <span class="dt">IO</span> a <span class="ot">-&gt;</span> (<span class="dt">Either</span> <span class="dt">SomeException</span> a <span class="ot">-&gt;</span> <span class="dt">IO</span> ()) <span class="ot">-&gt;</span> <span class="dt">IO</span> <span class="dt">ThreadId</span>
forkFinally action fun <span class="fu">=</span>
  mask <span class="fu">$</span> \restore <span class="ot">-&gt;</span>
    forkIO (<span class="kw">do</span> r <span class="ot">&lt;-</span> try (restore action); fun r)

<span class="ot">async ::</span> <span class="dt">IO</span> a <span class="ot">-&gt;</span> <span class="dt">IO</span> (<span class="dt">Async</span> a)
async action <span class="fu">=</span> <span class="kw">do</span>
  m <span class="ot">&lt;-</span> newEmptyMVar
  t <span class="ot">&lt;-</span> forkFinally action (putMVar m)
  return (<span class="dt">Async</span> t m)</code></pre></div>	

                <hr>

                <!-- <div id="disqus_thread"></div> -->
                <!-- <script> -->
                <!--   var disqus_config = function () { -->
                <!--   this.discovery.disable_promoted = 'true'; -->
                <!--   }; -->
                <!--   (function() { // DON'T EDIT BELOW THIS LINE -->
                <!--   var d = document, s = d.createElement('script'); -->

                <!--   s.src = '//fantasticsidtheblog.disqus.com/embed.js'; -->

                <!--   s.setAttribute('data-timestamp', +new Date()); -->
                <!--   (d.head || d.body).appendChild(s); -->
                <!--   })(); -->
                <!-- </script> -->
                <!-- <noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript" rel="nofollow">comments powered by Disqus.</a></noscript> -->

                <ul class="pager">
                    
                    
                </ul>

            </div>
        </div>
    </div>
</article>

        </div>
        <div id="footer">
        </div>
      <!-- Footer -->
<footer>
    <div class="container">
        <div class="row">
            <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
                <ul class="list-inline text-center">
                    <li>
                        <a href="../rss.xml" data-datatype="json" data-type="GET" data-target="#frame" class="reload" id="clickme">
                            <span class="fa-stack fa-lg">
                                <i class="fa fa-circle fa-stack-2x"></i>
                                <i class="fa fa-rss fa-stack-1x fa-inverse"></i>
                            </span>
                        </a>
                    </li>
                    
                    <li>
                        <a href="https://twitter.com/fantasticsid" data-datatype="json" data-type="GET" data-target="#frame" class="reload" id="clickme" target="_blank">
                            <span class="fa-stack fa-lg">
                                <i class="fa fa-circle fa-stack-2x"></i>
                                <i class="fa fa-twitter fa-stack-1x fa-inverse"></i>
                            </span>
                        </a>
                    </li>
                    
                    
                    <li>
                        <a href="https://www.facebook.com/lizhenchao" data-datatype="json" data-type="GET" data-target="#frame" class="reload" id="clickme" target="_blank">
                            <span class="fa-stack fa-lg">
                                <i class="fa fa-circle fa-stack-2x"></i>
                                <i class="fa fa-facebook fa-stack-1x fa-inverse"></i>
                            </span>
                        </a>
                    </li>
                     
                     
                    <li>
                        <a href="https://github.com/fantasticsid" target="_blank">
                            <span class="fa-stack fa-lg">

                              <i class="fa fa-arrow-circle-o-down"></i>
                                <i class="fa fa-circle fa-stack-2x"></i>
                                <i class="fa fa-github fa-stack-1x fa-inverse"></i>
                            </span>
                        </a>
                    </li>
                    
                    
                    <li>
                        <a href="https://instagram.com/zhenchao.li" target="_blank">
                            <span class="fa-stack fa-lg">

                              <i class="fa fa-arrow-circle-o-down"></i>
                                <i class="fa fa-circle fa-stack-2x"></i>
                                <i class="fa fa-instagram fa-stack-1x fa-inverse"></i>
                            </span>
                        </a>
                    </li>
                    
                </ul>
<div class="col-md-12">
     <p class="copyright text-muted">
            Site generated by
            <a href="http://jaspervdj.be/hakyll">Hakyll</a>. Modified theme inspired by
      <!-- ICE AND FIRE THEME https://github.com/SpaceG/iceandfire -->
    <a href="https://github.com/SpaceG/CleanMagicMedium-Jekyll">CleanMagic.</a> </p>
    </div>


    
            </div>
        </div>
    </div>
</footer>

<!-- jQuery -->
<script src="../static/js/jquery.min.js"></script>
<script src="../static/js/spaceg.stylesheets.min.js"></script> 
<script src="../static/js/bootstrap.min.js"></script>
<script src="https://cdn.rawgit.com/google/code-prettify/master/loader/run_prettify.js"></script>
<script src="../static/js/scripts.js"></script>



    </body>
</html>
