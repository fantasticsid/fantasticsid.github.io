<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <title>Real World Haskell 笔记 | fantasticsid</title>
    <meta name="author" content="fantasticsid">
    <meta name="description" content="Real World Haskell 笔记">
    <meta name="keywords" content="mathematics, computer science, haskell, clojure, scala, erlang, C++, python, music">

    <link rel="stylesheet" type="text/css" media="all" href="../stylesheets/screen.css">
    <link rel="stylesheet" type="text/css" href="../stylesheets/print.css" media="print">

    <link href="http://fonts.googleapis.com/css?family=Oxygen&amp;subset=latin,latin-ext" rel="stylesheet" type="text/css">

    <link rel="shortcut icon" type="image/png" href="../images/favicon.png">
  </head>

  <body class="post">
    <div id="bodywrapper">

      <div class="container">
        <article>
  <header>
    <div class="content">
    <p class="meta"><time class="timeago" datetime="2014-01-31" pubdate>2014-01-31</time></p>
    <h1>Real World Haskell 笔记</h1>
    </header>
  <section>
    <ol style="list-style-type: decimal">
<li>Getting Started</li>
</ol>
<p>介绍了Haskell的REPL: ghci. Haskell是强类型语言, 类型扮演了非常重要的角色.</p>
<ol start="2" style="list-style-type: decimal">
<li>Types and Functions</li>
</ol>
<p>类型推导. Haskell的一些基本类型: Char, Bool, Int, Integer, Double.</p>
<p>函数: Haskell函数几乎都是纯的, 即不带有副作用. 所谓副作用, 是指的函数的行为依赖于一些全局的状态.</p>
<p>Lazy Evaluation: Haskell的求值是惰性的. 表达式在需要其值的时候才会被真正求值, 在此之前, 它们以thunk的形式出现.</p>
<p>Curry and Partial Application</p>
<ol start="3" style="list-style-type: decimal">
<li>Defining Types, Streamlining Functions</li>
</ol>
<p>介绍了Haskell的Algebraic Data Types, Pattern Matching. Pattern Matching当中要注意pattern里面不能用同一个pattern变量代表2个值相等这样的限制.</p>
<p>Parameterized types, 类似于C++里的模板.</p>
<p>表达式缩进规则: 所有顶层定义的开始都要有一样的缩进, 如果下一行的开始缩进更大, 则被认为是当前表达式的延续. 如果是同一层, 则认为是同一个代码块的一个新项目. Structured Haskell Mode是一个Emacs Haskell的编辑模式, 通过parse haskell代码来推断缩进应该在哪里. Haskell里也可以用“{}”来组合代码, 并且用分号分割.</p>
<ol start="4" style="list-style-type: decimal">
<li>Functional Programming</li>
</ol>
<p>FP中递归是很重要的思想, 很多循环可以用尾递归的方式实现. 本章介绍了FP中很多List的函数, 比如map, foldl, foldr, head, init, inits, tail, tails等等.</p>
<p>As patterns.</p>
<p>Function composition with ‘.’ operator</p>
<p>seq能够对一个thunk进行严格求值(到head normal form).</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell">foldl' _ zero [] <span class="fu">=</span> zero
foldl' step zero (x<span class="fu">:</span>xs) <span class="fu">=</span>
       <span class="kw">let</span> new <span class="fu">=</span> step zero x
              <span class="kw">in</span> new <span class="ot">`seq`</span> foldl' step new xs</code></pre>
<ol start="5" style="list-style-type: decimal">
<li>Writing a Library: Working with JSON Data</li>
</ol>
<p>用Haskell的ADT表示JSON:</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">JValue</span> <span class="fu">=</span> <span class="dt">JString</span> <span class="dt">String</span>
              <span class="fu">|</span> <span class="dt">JNumber</span> <span class="dt">Double</span>
              <span class="fu">|</span> <span class="dt">JBool</span> <span class="dt">Bool</span>
              <span class="fu">|</span> <span class="dt">JNull</span>
              <span class="fu">|</span> <span class="dt">JObject</span> [(<span class="dt">String</span>, <span class="dt">JValue</span>)]
              <span class="fu">|</span> <span class="dt">JArray</span> [<span class="dt">JValue</span>]
                <span class="kw">deriving</span> (<span class="dt">Eq</span>, <span class="dt">Ord</span>, <span class="dt">Show</span>)</code></pre>
<p>Haskell代码一个文件通常代表一个Haskell Module</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">Module</span> <span class="dt">SimpleJSON</span>
  (
  <span class="dt">JValue</span>(<span class="fu">..</span>)
  , getString
  , getInt
  ) <span class="kw">where</span></code></pre>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">Module</span> <span class="dt">ExportNothing</span> () <span class="kw">where</span></code></pre>
<p>通用的PrettyPrinter</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">Doc</span> <span class="fu">=</span> <span class="dt">Empty</span>
         <span class="fu">|</span> <span class="dt">Char</span> <span class="dt">Char</span>
         <span class="fu">|</span> <span class="dt">Text</span> <span class="dt">String</span>
         <span class="fu">|</span> <span class="dt">Line</span>
         <span class="fu">|</span> <span class="dt">Concat</span> <span class="dt">Doc</span> <span class="dt">Doc</span>
         <span class="fu">|</span> <span class="dt">Union</span> <span class="dt">Doc</span> <span class="dt">Doc</span>
           <span class="kw">deriving</span> (<span class="dt">Show</span>,<span class="dt">Eq</span>)</code></pre>
<p>有了这个定义, 定义一些基本的combinator, 我们就可以对一个Doc进行渲染:</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">compact ::</span> <span class="dt">Doc</span> <span class="ot">-&gt;</span> <span class="dt">String</span>
compact x <span class="fu">=</span> transform [x]
    <span class="kw">where</span> transform [] <span class="fu">=</span> <span class="st">&quot;&quot;</span>
          transform (d<span class="fu">:</span>ds) <span class="fu">=</span>
              <span class="kw">case</span> d <span class="kw">of</span>
                <span class="dt">Empty</span>        <span class="ot">-&gt;</span> transform ds
                <span class="dt">Char</span> c       <span class="ot">-&gt;</span> c <span class="fu">:</span> transform ds
                <span class="dt">Text</span> s       <span class="ot">-&gt;</span> s <span class="fu">++</span> transform ds
                <span class="dt">Line</span>         <span class="ot">-&gt;</span> <span class="ch">'\n'</span> <span class="fu">:</span> transform ds
                a <span class="ot">`Concat`</span> b <span class="ot">-&gt;</span> transform (a<span class="fu">:</span>b<span class="fu">:</span>ds)
                _ <span class="ot">`Union`</span> b  <span class="ot">-&gt;</span> transform (b<span class="fu">:</span>ds)</code></pre>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">pretty ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Doc</span> <span class="ot">-&gt;</span> <span class="dt">String</span>
pretty width x <span class="fu">=</span> best <span class="dv">0</span> [x]
    <span class="kw">where</span> best col (d<span class="fu">:</span>ds) <span class="fu">=</span>
              <span class="kw">case</span> d <span class="kw">of</span>
                <span class="dt">Empty</span>        <span class="ot">-&gt;</span> best col ds
                <span class="dt">Char</span> c       <span class="ot">-&gt;</span> c <span class="fu">:</span>  best (col <span class="fu">+</span> <span class="dv">1</span>) ds
                <span class="dt">Text</span> s       <span class="ot">-&gt;</span> s <span class="fu">++</span> best (col <span class="fu">+</span> length s) ds
                <span class="dt">Line</span>         <span class="ot">-&gt;</span> <span class="ch">'\n'</span> <span class="fu">:</span> best <span class="dv">0</span> ds
                a <span class="ot">`Concat`</span> b <span class="ot">-&gt;</span> best col (a<span class="fu">:</span>b<span class="fu">:</span>ds)
                a <span class="ot">`Union`</span> b  <span class="ot">-&gt;</span> nicest col (best col (a<span class="fu">:</span>ds))
                                           (best col (b<span class="fu">:</span>ds))
          best _ _ <span class="fu">=</span> <span class="st">&quot;&quot;</span>

          nicest col a b <span class="fu">|</span> (width <span class="fu">-</span> least) <span class="ot">`fits`</span> a <span class="fu">=</span> a
                         <span class="fu">|</span> otherwise                <span class="fu">=</span> b
                         <span class="kw">where</span> least <span class="fu">=</span> min width col</code></pre>
<ol start="6" style="list-style-type: decimal">
<li>Using Typeclasses</li>
</ol>
<p>其实typeclass和C++的模板特列化(concept)有点相似. 但是typeclass有运行的额外开销.</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">class</span> <span class="dt">Eq</span> a <span class="kw">where</span>
  (<span class="fu">==</span>),<span class="ot"> (/=) ::</span> a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">Bool</span>
  x <span class="fu">/=</span> y <span class="fu">=</span> not (x <span class="fu">==</span> y)
  x <span class="fu">==</span> y <span class="fu">=</span> not (x <span class="fu">/=</span> y)</code></pre>
<p>Overlapping instances</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">class</span> <span class="dt">Borked</span> a <span class="kw">where</span>
<span class="ot">  bork ::</span> a <span class="ot">-&gt;</span> <span class="dt">String</span>
  
<span class="kw">instance</span> <span class="dt">Borked</span> <span class="dt">Int</span> <span class="kw">where</span>
  bork <span class="fu">=</span> show
  
<span class="kw">instance</span> <span class="dt">Borked</span> (<span class="dt">Int</span>, <span class="dt">Int</span>) <span class="kw">where</span>
  bork (a, b) <span class="fu">=</span> bork a <span class="fu">++</span> <span class="st">&quot;, &quot;</span> <span class="fu">++</span> bork b
  
<span class="kw">instance</span> (<span class="dt">Borked</span> a, <span class="dt">Borked</span> b) <span class="ot">=&gt;</span> <span class="dt">Borked</span> (a, b) <span class="kw">where</span>
 bork (a, b) <span class="fu">=</span> <span class="st">&quot;&gt;&gt;&quot;</span> <span class="fu">++</span> bork a <span class="fu">++</span> <span class="st">&quot; &quot;</span> <span class="fu">++</span> bork b <span class="fu">++</span> <span class="st">&quot;&lt;&lt;&quot;</span></code></pre>
<p>这个有点像C++的template specialization. 当然C++当中会使用最specific的template定义. 而Haskell则默认会拒绝自动选择一个定义, 除非使用了OverlappingInstances, TypeSynonymInstances这两个language extension.</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">{-# LANGUAGE TypeSynonymInstances, OverlappingInstances #-}</span>

<span class="kw">import</span> Data.List

<span class="kw">class</span> <span class="dt">Foo</span> a <span class="kw">where</span>
<span class="ot">  foo ::</span> a <span class="ot">-&gt;</span> <span class="dt">String</span>
  
<span class="kw">instance</span> <span class="dt">Foo</span> a <span class="ot">=&gt;</span> <span class="dt">Foo</span> [a] <span class="kw">where</span>
  foo <span class="fu">=</span> concat <span class="fu">.</span> intersperse <span class="st">&quot;, &quot;</span> <span class="fu">.</span> map foo
  
<span class="kw">instance</span> <span class="dt">Foo</span> <span class="dt">Char</span> <span class="kw">where</span>
  foo c <span class="fu">=</span> [c]
  
<span class="kw">instance</span> <span class="dt">Foo</span> <span class="dt">String</span> <span class="kw">where</span>
  foo <span class="fu">=</span> id</code></pre>
<p>Monomorphism restriction的原因是Haskell当中typeclass参数其实在运行时是需要有一个参数来代表具体instance的实现. (虚表?) 于是如果没有这个Monomorphism, 有的计算就有可能不得不进行2次, 因为编译器在编译一段代码的时候不能做出只算一次的决定.</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell">f xs <span class="fu">=</span> (len, len)
  <span class="kw">where</span> len <span class="fu">=</span> genericLength xs</code></pre>
<p>这段代码当中, f的类型应该是</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">f ::</span> <span class="dt">Num</span> t <span class="ot">=&gt;</span> [b] <span class="ot">-&gt;</span> (t, t)</code></pre>
<p>如果我们想要使得f的类型中t代表不同的类型:</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">f ::</span> (<span class="dt">Num</span> b, <span class="dt">Num</span> c) <span class="ot">=&gt;</span> [a] <span class="ot">-&gt;</span> (b, c)
f xs <span class="fu">=</span> (len, len)
  <span class="kw">where</span> len <span class="fu">=</span> genericLength xs</code></pre>
<p>则会出现编译错误, 因为编译器觉得这里要进行两次对len的计算, 而这是Hughes认为不对的, 至少不能是默认的行为.</p>
<p>解决这个错误的方法有几个:</p>
<ul>
<li>给函数参数显式binding</li>
<li>给函数加上适当的类型签名</li>
<li>加上{-# LANGUAGE NoMonomorphismRestriction #-}</li>
</ul>
<ol start="7" style="list-style-type: decimal">
<li>I/O</li>
</ol>
<p>I/O在Haskell里是比较神奇的东西:</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">let</span> writefoo <span class="fu">=</span> putStrLn <span class="st">&quot;foo&quot;</span></code></pre>
<p>这段代码不会输出“foo”, 而是把putStrLn “foo”这个I/O computation绑定到writefoo. 所以这里的代码就像数据一样. “Code is data, data is code”.</p>
<p>但是这段代码放在另外一个I/O action里就会被执行.</p>
<p>同样, 在ghci里也会被执行, 原因是ghci其实是在I/O monad中执行.</p>
<p>openFile, hPutStrLn, hPrint, putStrLn, hClose</p>
<p>hSeek, hTell, AbsoluteSeek, RelativeSeek, hIsSeekable</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell">main <span class="fu">=</span> <span class="kw">do</span>
  inh <span class="ot">&lt;-</span> openFile <span class="st">&quot;input.txt&quot;</span> <span class="dt">ReadMode</span>
  seekable <span class="ot">&lt;-</span> hIsSeekable inh
  hSeek inh <span class="dt">RelativeSeek</span> <span class="dv">1</span>
  line <span class="ot">&lt;-</span> hGetLine inh
  putStrLn line
  hClose inh</code></pre>
<p>System.Directory</p>
<p>removeFile, renameFile</p>
<p>openTempFile, openBinaryTempFile</p>
<p>System.Directory.getTemporaryDirectory</p>
<p>hGetContents因为lazy evaluation所以在读大文件的时候不会有内存不够的问题(视情况)</p>
<p>readFile, writeFile</p>
<p>interact :: (String -&gt; String) -&gt; IO ()</p>
<p>System.Environment.getArgs System.Environment.getProgName System.Environment.genEnv</p>
<ol start="8" style="list-style-type: decimal">
<li>Efficient File Processing, Regular Expressions, and Filename Matching</li>
</ol>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">import</span> <span class="kw">qualified</span> Data.ByteString.Lazy <span class="kw">as</span> L

<span class="ot">hasElfMagic ::</span>  <span class="dt">L.ByteString</span> <span class="ot">-&gt;</span> <span class="dt">Bool</span>
hasElfMagic content <span class="fu">=</span> L.take <span class="dv">4</span> content <span class="fu">==</span> elfMagic
  <span class="kw">where</span> elfMagic <span class="fu">=</span> L.pack [<span class="dv">0x7f</span>, <span class="dv">0x45</span>, <span class="dv">0x4c</span>, <span class="dv">0x46</span>]

<span class="ot">isElfFile ::</span>  FilePath <span class="ot">-&gt;</span> <span class="dt">IO</span> <span class="dt">Bool</span>
isElfFile path <span class="fu">=</span> <span class="kw">do</span>
  content <span class="ot">&lt;-</span> L.readFile path
  return (hasElfMagic content)</code></pre>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">import</span> System.IO
<span class="kw">import</span> Control.Applicative
<span class="kw">import</span> Data.List

<span class="kw">import</span> <span class="kw">qualified</span> Data.ByteString <span class="kw">as</span> B
<span class="kw">import</span> <span class="kw">qualified</span> Data.ByteString.Char8 <span class="kw">as</span> C

main <span class="fu">=</span> <span class="kw">do</span> inh <span class="ot">&lt;-</span> openFile <span class="st">&quot;data.txt&quot;</span> <span class="dt">ReadMode</span>
          content <span class="ot">&lt;-</span> B.hGetContents inh
          putStrLn <span class="fu">$</span> (show <span class="fu">.</span> foldl (liftA2 (<span class="fu">+</span>)) (<span class="dt">Just</span> <span class="dv">0</span>) <span class="fu">.</span> (map (fmap fst <span class="fu">.</span> C.readInt)) <span class="fu">.</span> C.lines) content</code></pre>
<p>为何以上程序在解释模式下, 比python更慢?</p>
<p>Regular Expressions</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">import</span> Text.Regex.Posix.Wrap
<span class="fu">:</span>t (<span class="fu">=~</span>)
(<span class="fu">=~</span>)
<span class="ot">  ::</span> (<span class="dt">Text.Regex.Base.RegexLike.RegexContext</span> <span class="dt">Regex</span> source1 target,
      <span class="dt">Text.Regex.Base.RegexLike.RegexMaker</span>
        <span class="dt">Regex</span> <span class="dt">CompOption</span> <span class="dt">ExecOption</span> source) <span class="ot">=&gt;</span>
     source1 <span class="ot">-&gt;</span> source <span class="ot">-&gt;</span> target</code></pre>
<ol start="9" style="list-style-type: decimal">
<li>I/O Case Study: A Library for Searching the Filesystem</li>
</ol>
<p>Control.Exception</p>
<p>bracket :: IO a -&gt; (a -&gt; IO b) -&gt; (a -&gt; IO c) -&gt; IO c</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell">getFileSize path <span class="fu">=</span> handle (\_ <span class="ot">-&gt;</span> return <span class="dt">Nothing</span>) <span class="fu">$</span>
  bracket (openFile path <span class="dt">ReadMode</span>) hClose <span class="fu">$</span> \h <span class="ot">-&gt;</span> <span class="kw">do</span>
    size <span class="ot">&lt;-</span> hFileSize h
    return (<span class="dt">Just</span> size)</code></pre>
<p>eDSL</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">type</span> <span class="dt">InfoP</span> a <span class="fu">=</span> FilePath
            <span class="ot">-&gt;</span> <span class="dt">Permissions</span>
            <span class="ot">-&gt;</span> <span class="dt">Maybe</span> <span class="dt">Integer</span>
            <span class="ot">-&gt;</span> <span class="dt">ClockTime</span>
            <span class="ot">-&gt;</span> a
<span class="ot">pathP ::</span> <span class="dt">InfoP</span> FilePath</code></pre>
<p>这样我们就能构造各种类型的Predicate/Extractor</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">sizeP ::</span> <span class="dt">InfoP</span> <span class="dt">Integer</span> <span class="co">-- 输入FilePath的信息, 返回Integer的函数类型</span>
sizeP _ _ (<span class="dt">Just</span> size) _ <span class="fu">=</span> size
sizeP _ _ <span class="dt">Nothing</span> _ <span class="fu">=</span> <span class="fu">-</span><span class="dv">1</span></code></pre>
<p>这是一个Extractor</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">equalP ::</span> (<span class="dt">Eq</span> a) <span class="ot">=&gt;</span> <span class="dt">InfoP</span> a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">InfoP</span> <span class="dt">Bool</span>
equalP f k <span class="fu">=</span> \w x y z <span class="ot">-&gt;</span> f w x y z <span class="fu">==</span> k</code></pre>
<p>这是一个Predicate</p>
<p>当然也可以写成</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">equalP' ::</span> (<span class="dt">Eq</span> a) <span class="ot">=&gt;</span> <span class="dt">InfoP</span> a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">InfoP</span> <span class="dt">Bool</span>
equalP' f k w x y z <span class="fu">=</span> f w x y z <span class="fu">==</span> k</code></pre>
<p>我们还可以继续抽象:</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">liftP ::</span> (a <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> c) <span class="ot">-&gt;</span> <span class="dt">InfoP</span> a <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> <span class="dt">InfoP</span> c
liftP q f k w x y z <span class="fu">=</span> f w x y z <span class="ot">`q`</span> k

greaterP,<span class="ot"> lesserP ::</span> (<span class="dt">Ord</span> a) <span class="ot">=&gt;</span> <span class="dt">InfoP</span> a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">InfoP</span> <span class="dt">Bool</span>
greaterP <span class="fu">=</span> liftP (<span class="fu">&gt;</span>)
lesserP <span class="fu">=</span> liftP (<span class="fu">&lt;</span>)</code></pre>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">liftPath ::</span> (FilePath <span class="ot">-&gt;</span> a) <span class="ot">-&gt;</span> <span class="dt">InfoP</span> a
liftPath f w _ _ _ <span class="fu">=</span> f w</code></pre>
<ol start="28" style="list-style-type: decimal">
<li>Software Transactional Memory</li>
</ol>
<p>传统的并发是基于锁和条件变量的, 而使用过程中会有各种问题:</p>
<ul>
<li>忘了锁的释放</li>
<li>加锁顺序的问题导致思索</li>
<li>异常处理</li>
<li>忘了唤醒等待线程</li>
</ul>
<p>STM代表一个事务, 他们之间可以组合, 并且最终通过atomically在IO monad中执行, 而STM之间的执行是相互分离的.</p>
<p>一个STM完成时, 会发生这几件事之一:</p>
<ul>
<li><p>如果其他线程没有对STM修改的数据进行修改, 则STM的修改同时生效</p></li>
<li><p>否则, STM会重启</p></li>
</ul>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">Item</span> <span class="fu">=</span> <span class="dt">Scroll</span>
          <span class="fu">|</span> <span class="dt">Wand</span>
          <span class="fu">|</span> <span class="dt">Banjo</span>
            <span class="kw">deriving</span> (<span class="dt">Eq</span>, <span class="dt">Ord</span>, <span class="dt">Show</span>)

<span class="kw">newtype</span> <span class="dt">Gold</span> <span class="fu">=</span> <span class="dt">Gold</span> <span class="dt">Int</span>
    <span class="kw">deriving</span> (<span class="dt">Eq</span>, <span class="dt">Ord</span>, <span class="dt">Show</span>, <span class="dt">Num</span>)

<span class="kw">newtype</span> <span class="dt">HitPoint</span> <span class="fu">=</span> <span class="dt">HitPoint</span> <span class="dt">Int</span>
    <span class="kw">deriving</span> (<span class="dt">Eq</span>, <span class="dt">Ord</span>, <span class="dt">Show</span>, <span class="dt">Num</span>)

<span class="kw">type</span> <span class="dt">Inventory</span> <span class="fu">=</span> <span class="dt">TVar</span> [<span class="dt">Item</span>]
<span class="kw">type</span> <span class="dt">Health</span> <span class="fu">=</span> <span class="dt">TVar</span> <span class="dt">HitPoint</span>
<span class="kw">type</span> <span class="dt">Balance</span> <span class="fu">=</span> <span class="dt">TVar</span> <span class="dt">Gold</span>

<span class="kw">data</span> <span class="dt">Player</span> <span class="fu">=</span> <span class="dt">Player</span> {
<span class="ot">    balance ::</span> <span class="dt">Balance</span>,
<span class="ot">    health ::</span> <span class="dt">Health</span>,
<span class="ot">    inventory ::</span> <span class="dt">Inventory</span>
}</code></pre>
<p>一些API:</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">atomically ::</span> <span class="dt">STM</span> a <span class="ot">-&gt;</span> <span class="dt">IO</span> a

<span class="ot">newTVar ::</span> a <span class="ot">-&gt;</span> <span class="dt">STM</span> (<span class="dt">TVar</span> a)

<span class="ot">readTVar ::</span> <span class="dt">TVar</span> a <span class="ot">-&gt;</span> <span class="dt">STM</span> a

<span class="ot">writeTVar ::</span> <span class="dt">TVar</span> a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">STM</span> ()

<span class="ot">retry ::</span> <span class="dt">STM</span> a</code></pre>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">transfer ::</span> <span class="dt">Gold</span> <span class="ot">-&gt;</span> <span class="dt">Balance</span> <span class="ot">-&gt;</span> <span class="dt">Balance</span> <span class="ot">-&gt;</span> <span class="dt">STM</span> ()

transfer qty fromBal toBal <span class="fu">=</span> <span class="kw">do</span>
  fromQty <span class="ot">&lt;-</span> readTVar fromBal
  when (qty <span class="fu">&gt;</span> fromQty) <span class="fu">$</span>
    retry
  writeTVar fromBal (fromQty <span class="fu">-</span> qty)
  readTVar toBal <span class="fu">&gt;&gt;=</span> writeTVar toBal <span class="fu">.</span> (qty <span class="fu">+</span>)</code></pre>
<p>retry在重启一个STM的时候, 会阻塞在之前改变的TVar上, 直到其中一个有改变.</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">orElse ::</span> <span class="dt">STM</span> a <span class="ot">-&gt;</span> <span class="dt">STM</span> a <span class="ot">-&gt;</span> <span class="dt">STM</span> a</code></pre>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">someAction ::</span> <span class="dt">IO</span> a

<span class="ot">stmTransaction ::</span> <span class="dt">STM</span> (<span class="dt">IO</span> a)
stmTransaction <span class="fu">=</span> return someAction

<span class="ot">doSomething ::</span> <span class="dt">IO</span> a
doSomething <span class="fu">=</span> join (atomically stmTransaction)</code></pre>
<p>也可以在STM中进行IO操作</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">unsafeIOToSTM ::</span> <span class="dt">IO</span> a <span class="ot">-&gt;</span> <span class="dt">STM</span> a</code></pre>
<p>但是用了它STM存在的意义就少了一半了.</p>
<p>Pattern guards</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">{-# LANGUAGE PatternGuards #-}</span>
testme x xs <span class="fu">|</span> <span class="dt">Just</span> y <span class="ot">&lt;-</span> lookup x xs, y <span class="fu">&gt;</span> <span class="dv">3</span> <span class="fu">=</span> y <span class="fu">|</span> otherwise <span class="fu">=</span><span class="dv">0</span></code></pre>
<p>Invariant</p>
<p>STM存在的意义在于, 我们能够更容易地写出保持invariant的代码.</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">alwaysSucceeds ::</span> <span class="dt">STM</span> a <span class="ot">-&gt;</span> <span class="dt">STM</span> ()</code></pre>
  </section>

  <section id="comment">

    <div id="disqus_thread"></div>
    <script type="text/javascript">
      /* * * CONFIGURATION VARIABLES: EDIT BEFORE PASTING INTO YOUR WEBPAGE * * */
      var disqus_shortname = 'fantasticsidtheblog'; // required: replace example with your forum shortname

      /* * * DON'T EDIT BELOW THIS LINE * * */
      (function() {
      var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
      dsq.src = 'http://' + disqus_shortname + '.disqus.com/embed.js';
      (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
      })();
    </script>
    <noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
    <a href="http://disqus.com" class="dsq-brlink">blog comments powered by <span class="logo-disqus">Disqus</span></a>
  </section>
</article>

      </div>

      <footer>
          <div class="contact">
            <a href="../" title="home">home</a>
            <a href="../code.html" title="code">code</a>
            <a href="../about.html" title="about fantasticsid">about</a>
            <a href="../rss.xml" title="subscribe">rss</a>
          </div>
      </footer>

    </div>

    <script type="text/javascript" src="../javascripts/jquery.min.js"></script>
    <script type="text/javascript" src="../javascripts/jquery.timeago.js"></script>
    <script type="text/javascript" src="../javascripts/jquery.easing.js"></script>
    <script type="text/javascript" src="../javascripts/jquery.anchorscroll.js"></script>
    <script type="text/javascript" src="../javascripts/blog.ui.js"></script>
  </body>
</html>
